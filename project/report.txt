Coverage Report by file with details

Total Coverage By File (code coverage only, filtered view): 85.2%

File: draw_any_octant.vhd
Statement Coverage:
    Enabled Coverage        Active      Hits    Misses % Covered
    ----------------        ------      ----    ------ ---------
    Stmts                        8         8         0     100.0

================================Statement Details================================

Statement Coverage for file draw_any_octant.vhd --

    1                                              LIBRARY IEEE;
    2                                              
    3                                              USE IEEE.std_logic_1164.ALL;
    4                                              USE IEEE.numeric_std.ALL;
    5                                              
    6                                              
    7                                              PACKAGE dao IS
    8                                                
    9                                                TYPE xy IS (xcoord,ycoord);
    10                                               
    11                                               TYPE control IS
    12                                               RECORD
    13                                                 swapxy, negx, negy: std_logic;
    14                                               END RECORD;
    15                                               
    16                                             END PACKAGE dao;
    17                                             
    18                                             
    19                                             
    20                                             
    21                                             LIBRARY IEEE;
    22                                             
    23                                             USE IEEE.std_logic_1164.ALL;
    24                                             USE IEEE.numeric_std.ALL;
    25                                             USE WORK.dao.ALL;
    26                                             
    27                                             
    28                                             
    29                                             ENTITY draw_any_octant IS
    30                                               
    31                                               -- swapxy negx  negy  octant
    32                                               --  0      0      0     ENE
    33                                               --  1      0      0     NNE
    34                                               --  1      1      0     NNW
    35                                               --  0      1      0     WNW
    36                                               --  0      1      1     WSW
    37                                               --  1      1      1     SSW
    38                                               --  1      0      1     SSE
    39                                               --  0      0      1     ESE
    40                                             
    41                                               -- swapxy: x & y swap round on inputs & outputs
    42                                               -- negx:   invert bits of x on inputs & outputs
    43                                               -- negy:   invert bits of y on inputs & outputs
    44                                             
    45                                               -- xbias always give nias in x axis direction, 
    46                                               -- so swapxy must invert xbias
    47                                               
    48                                               GENERIC(
    49                                             	vsize1: INTEGER := 6
    50                                             	);
    51                                             	
    52                                               PORT(
    53                                                 clk, resetx, draw, xbias, disable : IN  std_logic;
    54                                                 xin, yin                : IN  std_logic_vector(vsize1-1 DOWNTO 0);
    55                                                 done                    : OUT std_logic;
    56                                                 x, y                    : OUT std_logic_vector(vsize1-1 DOWNTO 0);
    57                                                 swapxy,negx,negy        : IN std_logic
    58                                                 );
    59                                             END ENTITY draw_any_octant;
    60                                             
    61                                             ARCHITECTURE comb OF draw_any_octant IS
    62                                             
    63                                               SUBTYPE vvec IS std_logic_vector(vsize1-1 DOWNTO 0);
    64                                             
    65                                               TYPE xycoord IS ARRAY (xy) OF vvec;
    66                                             
    67                                             
    68                                               FUNCTION swap(z:xycoord; c: control) RETURN xycoord IS
    69                                               BEGIN
    70                                                 IF c.swapxy = '1' THEN
    71            1                        361           RETURN (z(ycoord), z(xcoord));
    72                                                 ELSE
    73            1                        578           RETURN z;
    74                                                 END IF;
    75                                               END FUNCTION swap;
    76                                             
    77                                               FUNCTION inv(z: xycoord; c: control) RETURN xycoord IS
    78                                               BEGIN
    79            1                        939         RETURN (z(xcoord) XOR vvec'(OTHERS=>c.negx), z(ycoord) XOR vvec'(OTHERS=>c.negy));
    80                                               END FUNCTION inv;
    81                                                 
    82                                             
    83                                               SIGNAL xyin_i, xy_i: xycoord;
    84                                               SIGNAL xbias_i: std_logic;
    85                                               SIGNAL c, c_delayed: control;
    86                                             
    87                                             BEGIN
    88                                             
    89                                             
    90                                             
    91                                             
    92                                             
    93                                               D_O: ENTITY  WORK.draw_octant
    94                                                 GENERIC MAP(
    95                                                   vsize => vsize1
    96                                                 )
    97                                                 PORT MAP (
    98                                                   disable => disable,
    99                                                   clk   => clk,
    100                                                  init => resetx,
    101                                                  draw  => draw,
    102                                                  xbias => xbias_i,
    103                                                  xin   => xyin_i(xcoord),
    104                                                  yin   => xyin_i(ycoord),
    105                                                  done  => done,
    106                                                  x     => xy_i(xcoord),
    107                                                  y     => xy_i(ycoord)
    108                                                  );
    109                                              
    110                                              R1: PROCESS
    111                                              BEGIN
    112                                                WAIT UNTIL clk'EVENT and clk='1';
    113           1                    2958385         c_delayed <= c;
    114                                              END PROCESS R1;
    115                                              
    116           1                        290       xyin_i <= swap( inv((xin, yin), c), c);
    117           1                        649       (x,y) <= inv( swap(xy_i, c_delayed), c_delayed);
    118                                              
    119           1                         58       xbias_i <= xbias XOR swapxy;
    120           1                         97       c <= (swapxy, negx, negy);
    121                                            
    122                                            END ARCHITECTURE comb;

Branch Coverage:
    Enabled Coverage        Active      Hits    Misses % Covered
    ----------------        ------      ----    ------ ---------
    Branches                     2         2         0     100.0

================================Branch Details================================

Branch Coverage for file draw_any_octant.vhd --

------------------------------------IF Branch------------------------------------
    70                                     939     Count coming in to IF
    70            1                        361         IF c.swapxy = '1' THEN
    72            1                        578         ELSE
Branch totals: 2 hits of 2 branches = 100.0%


Condition Coverage:
    Enabled Coverage        Active   Covered    Misses % Covered
    ----------------        ------      ----    ------ ---------
    FEC Condition Terms          0         0         0     100.0
Expression Coverage:
    Enabled Coverage        Active   Covered    Misses % Covered
    ----------------        ------      ----    ------ ---------
    FEC Expression Terms         2         2         0     100.0

================================Expression Details================================

Expression Coverage for file draw_any_octant.vhd --

----------------Focused Expression View-----------------
Line       119 Item    1   xbias_i <= xbias XOR swapxy;
Expression totals: 2 of 2 input terms covered = 100.0%

  Input Term   Covered  Reason for no coverage                  Hint
 -----------  --------  --------------------------------------  --------------
       xbias         Y
      swapxy         Y

    Rows:   Hits(->0)   Hits(->1)  FEC Target            Matching input patterns(->0)         Matching input patterns(->1)
---------  ----------  ----------  --------------------  -----------------------------------  -----------------------------------
 Row   1:          12           8  xbias_0               { 00 }                               { 01 }
 Row   2:          14          23  xbias_1               { 11 }                               { 10 }
 Row   3:          12          23  swapxy_0              { 00 }                               { 10 }
 Row   4:          14           8  swapxy_1              { 11 }                               { 01 }

NOTE:
  * Order of matching input pattern values: {xbias,swapxy}


FSM Coverage:
    Enabled Coverage        Active      Hits    Misses % Covered
    ----------------        ------      ----    ------ ---------
    States                       0         0         0     100.0
    Transitions                  0         0         0     100.0
Toggle Coverage:
    Enabled Coverage        Active      Hits    Misses % Covered
    ----------------        ------      ----    ------ ---------
    Toggle Bins                 80        80         0     100.0

================================Toggle Details================================

Toggle Coverage for File draw_any_octant.vhd --

       Line                                   Node      1H->0L      0L->1H                          "Coverage"
--------------------------------------------------------------------------------------------------------------
         53                                  xbias           1           1                              100.00 
         53                                 resetx           1           1                              100.00 
         53                                   draw           1           1                              100.00 
         53                                disable           1           1                              100.00 
         53                                    clk           1           1                              100.00 
         54                                 yin(5)           1           1                              100.00 
         54                                 yin(4)           1           1                              100.00 
         54                                 yin(3)           1           1                              100.00 
         54                                 yin(2)           1           1                              100.00 
         54                                 yin(1)           1           1                              100.00 
         54                                 yin(0)           1           1                              100.00 
         54                                 xin(5)           1           1                              100.00 
         54                                 xin(4)           1           1                              100.00 
         54                                 xin(3)           1           1                              100.00 
         54                                 xin(2)           1           1                              100.00 
         54                                 xin(1)           1           1                              100.00 
         54                                 xin(0)           1           1                              100.00 
         55                                   done           1           1                              100.00 
         56                                   y(5)           1           1                              100.00 
         56                                   y(4)           1           1                              100.00 
         56                                   y(3)           1           1                              100.00 
         56                                   y(2)           1           1                              100.00 
         56                                   y(1)           1           1                              100.00 
         56                                   y(0)           1           1                              100.00 
         56                                   x(5)           1           1                              100.00 
         56                                   x(4)           1           1                              100.00 
         56                                   x(3)           1           1                              100.00 
         56                                   x(2)           1           1                              100.00 
         56                                   x(1)           1           1                              100.00 
         56                                   x(0)           1           1                              100.00 
         57                                 swapxy           1           1                              100.00 
         57                                   negy           1           1                              100.00 
         57                                   negx           1           1                              100.00 
         84                                xbias_i           1           1                              100.00 
         85                       c_delayed.swapxy           1           1                              100.00 
         85                         c_delayed.negy           1           1                              100.00 
         85                         c_delayed.negx           1           1                              100.00 
         85                               c.swapxy           1           1                              100.00 
         85                                 c.negy           1           1                              100.00 
         85                                 c.negx           1           1                              100.00 

Total Node Count     =         40 
Toggled Node Count   =         40 
Untoggled Node Count =          0 

Toggle Coverage      =      100.0% (80 of 80 bins)

File: draw_octant.vhd
Statement Coverage:
    Enabled Coverage        Active      Hits    Misses % Covered
    ----------------        ------      ----    ------ ---------
    Stmts                       25        25         0     100.0

================================Statement Details================================

Statement Coverage for file draw_octant.vhd --

    1                                              -- Thomas Clarke 2013
    2                                              -- draw-octant entity modified for variable size vectors
    3                                              -- used in VHDL & Logic Synthesis Coursework
    4                                              
    5                                              LIBRARY IEEE;
    6                                              
    7                                              USE IEEE.std_logic_1164.ALL;
    8                                              USE IEEE.numeric_std.ALL;
    9                                              
    10                                             ENTITY draw_octant IS
    11                                               GENERIC(vsize: INTEGER := 6);
    12                                               PORT(
    13                                                 clk, init, draw, xbias, disable : IN  std_logic;
    14                                                 xin, yin                 : IN  std_logic_vector(vsize-1 DOWNTO 0);
    15                                                 done                     : OUT std_logic;
    16                                                 x, y                     : OUT std_logic_vector(vsize-1 DOWNTO 0)
    17                                                 );
    18                                             END ENTITY draw_octant;
    19                                             
    20                                             ARCHITECTURE comb OF draw_octant IS
    21                                             
    22                                               SIGNAL done1                    : std_logic; -- internal done
    23                                               SIGNAL x1, y1                   : unsigned(vsize-1 DOWNTO 0); -- internal x,y
    24                                               SIGNAL xincr, yincr, xnew, ynew : unsigned(vsize-1 DOWNTO 0);
    25                                               -- note on vector sizes. err1,err2 must be one bit larger to preserve signed error info
    26                                               -- error is always adjusted to minimise absolute value of signed error and therefore 
    27                                               -- can never be larger than vsize bits even though also signed, 12 bits is enough
    28                                               SIGNAL error                    : signed(vsize-1 DOWNTO 0);
    29                                               SIGNAL err1, err2               : unsigned(vsize DOWNTO 0);
    30                                             
    31                                             -- OPERATION
    32                                             --
    33                                             -- line drawing is initiated by asserting init and draw in successive cycles.
    34                                             -- this loads the initial and final coordinates of the line to be drawn into
    35                                             -- (x,y) and xnew,ynew0 respectively
    36                                             -- drawing must be in ENE octant which implies xincr >= 0, yincr >= 0, xincr >= yincr
    37                                             -- here xincr = x - xnew, yincr = y - ynew
    38                                             --
    39                                             -- Through the drawing process (x,y) represent a new point to be plotted on line each cycle.
    40                                             -- error represents the signed
    41                                             --
    42                                             -- xbias determines whether line goes in x direction or xy direction when both directions have
    43                                             -- equal offset from the true line.
    44                                             --
    45                                             -- done is asserted in the final cycle when x=xnew, y=ynew.
    46                                             
    47                                             --NOTES ON DATA STRUCTURES
    48                                             -- The basic data here is a (x,y) coordinate
    49                                             -- it would make sense to use a record type for this:
    50                                             -- TYPE coord IS RECORD x,y: std-logic_vector(vsize-1 DOWNTO 0) END RECORD;
    51                                             -- then decalre internal datas tructures of type coord.
    52                                             -- the result would be neater, and for example testing the end condition could 
    53                                             -- be equality on records which works (like equality on arrays)
    54                                             
    55                                             
    56                                             BEGIN
    57                                               -- assign to ports from internal signals
    58            1                        551       x    <= std_logic_vector(x1);
    59            1                        149       y    <= std_logic_vector(y1);
    60            1                         91       done <= done1;
    61                                             
    62            1                        748       C1 : PROCESS(error, xincr, yincr, x1, y1, xnew, ynew, init, draw)
    63                                                 
    64                                               BEGIN
    65                                             
    66            1                        748         err1 <= unsigned(abs(resize(error, vsize+1) + signed(resize(yincr,vsize+1))));
    67            1                        748         err2 <= unsigned(abs(resize(error, vsize+1) - signed(resize(unsigned(xincr - yincr),vsize+1))));
    68                                             
    69            1                        748         done1 <= '0';
    70                                                 IF x1 = xnew and y1 = ynew and init = '0' and draw = '0' THEN
    71            1                         45           done1 <= '1';
    72                                                 END IF;
    73                                             
    74                                               END PROCESS C1;
    75                                             
    76                                               R1 : PROCESS
    77                                             
    78                                               BEGIN
    79                                                 WAIT UNTIL clk'event AND clk = '1';
    80                                                 IF disable = '0' THEN
    81                                                   IF init = '1' THEN
    82            1                         45             x1    <= unsigned(xin);
    83            1                         45             y1    <= unsigned(yin);
    84            1                         45             xincr <= (OTHERS => '0');
    85            1                         45             yincr <= (OTHERS => '0');
    86            1                         45             xnew  <= unsigned(xin);
    87            1                         45             ynew  <= unsigned(yin);
    88            1                         45             error <= (OTHERS => '0');
    89                                                   
    90                                                   ELSIF draw = '1' THEN
    91            1                         45             xincr <= unsigned(xin) - x1;
    92            1                         45             yincr <= unsigned(yin) - y1;
    93            1                         45             xnew  <= unsigned(xin);
    94            1                         45             ynew  <= unsigned(yin);
    95                                                   
    96                                                   ELSIF done1 = '1' THEN
    97            1                    2532504             NULL; -- do nothing more once line has finished until next init
    98                                             
    99                                             	  ELSE    -- draw new pixel
    100                                                 
    101                                                    IF err1 > err2 OR (err1 = err2 AND xbias = '0') THEN --check new pixel direction
    102                                                      -- draw new pixel in diagonal direction
    103           1                        120               y1    <= y1 + 1;
    104           1                        120               x1    <= x1 + 1;
    105           1                        120               error <= error + signed(yincr) - signed(xincr);
    106                                                    ELSE
    107                                                      -- draw new pixel in x direction
    108           1                        415               x1    <= x1 + 1;
    109           1                        415               error <= error + signed(yincr);
    110                                                 
    111                                                    END IF;
    112                                            
    113                                                  END IF;
    114                                            
    115                                                END IF;
    116                                                
    117                                              END PROCESS R1;
    118                                            
    119                                            END ARCHITECTURE comb;
    120                                            

Branch Coverage:
    Enabled Coverage        Active      Hits    Misses % Covered
    ----------------        ------      ----    ------ ---------
    Branches                    10        10         0     100.0

================================Branch Details================================

Branch Coverage for file draw_octant.vhd --

------------------------------------IF Branch------------------------------------
    70                                     748     Count coming in to IF
    70            1                         45         IF x1 = xnew and y1 = ynew and init = '0' and draw = '0' THEN
                                           703     All False Count
Branch totals: 2 hits of 2 branches = 100.0%

------------------------------------IF Branch------------------------------------
    80                                 2958385     Count coming in to IF
    80            1                    2533129         IF disable = '0' THEN
                                        425256     All False Count
Branch totals: 2 hits of 2 branches = 100.0%

------------------------------------IF Branch------------------------------------
    81                                 2533129     Count coming in to IF
    81            1                         45           IF init = '1' THEN
    90            1                         45           ELSIF draw = '1' THEN
    96            1                    2532504           ELSIF done1 = '1' THEN
    99            1                        535     	  ELSE    -- draw new pixel
Branch totals: 4 hits of 4 branches = 100.0%

------------------------------------IF Branch------------------------------------
    101                                    535     Count coming in to IF
    101           1                        120             IF err1 > err2 OR (err1 = err2 AND xbias = '0') THEN --check new pixel direction
    106           1                        415             ELSE
Branch totals: 2 hits of 2 branches = 100.0%


Condition Coverage:
    Enabled Coverage        Active   Covered    Misses % Covered
    ----------------        ------      ----    ------ ---------
    FEC Condition Terms          7         6         1      85.7

================================Condition Details================================

Condition Coverage for file draw_octant.vhd --

----------------Focused Condition View-------------------
Line       70 Item    1     IF x1 = xnew and y1 = ynew and init = '0' and draw = '0' THEN
Condition totals: 3 of 4 input terms covered = 75.0%

    Input Term   Covered  Reason for no coverage   Hint
   -----------  --------  -----------------------  --------------
   (x1 = xnew)         Y
   (y1 = ynew)         N  '_0' not hit             Hit '_0'
  (init = '0')         Y
  (draw = '0')         Y

     Rows:       Hits  FEC Target            Matching input patterns       
 ---------  ---------  --------------------  -------------------------     
  Row   1:        569  (x1 = xnew)_0         { 0--- }                      
  Row   2:         45  (x1 = xnew)_1         { 1111 }                      
  Row   3:    ***0***  (y1 = ynew)_0         { 10-- }                      
  Row   4:         45  (y1 = ynew)_1         { 1111 }                      
  Row   5:         89  (init = '0')_0        { 110- }                      
  Row   6:         45  (init = '0')_1        { 1111 }                      
  Row   7:         45  (draw = '0')_0        { 1110 }                      
  Row   8:         45  (draw = '0')_1        { 1111 }                      

NOTE:
  * Order of matching input pattern values: {(x1 = xnew),(y1 = ynew),(init = '0'),(draw = '0')}

----------------Focused Condition View-------------------
Line       101 Item    1         IF err1 > err2 OR (err1 = err2 AND xbias = '0') THEN --check new pixel direction
Condition totals: 3 of 3 input terms covered = 100.0%

     Input Term   Covered  Reason for no coverage   Hint
    -----------  --------  -----------------------  --------------
  (err1 > err2)         Y
  (err1 = err2)         Y
  (xbias = '0')         Y

     Rows:       Hits  FEC Target            Matching input patterns       
 ---------  ---------  --------------------  -------------------------     
  Row   1:        415  (err1 > err2)_0       { 00- 010 }                   
  Row   2:        100  (err1 > err2)_1       { 1-- }                       
  Row   3:        395  (err1 = err2)_0       { 00- }                       
  Row   4:         20  (err1 = err2)_1       { 011 }                       
  Row   5:         20  (xbias = '0')_0       { 010 }                       
  Row   6:         20  (xbias = '0')_1       { 011 }                       

NOTE:
  * Order of matching input pattern values: {(err1 > err2),(err1 = err2),(xbias = '0')}


Expression Coverage:
    Enabled Coverage        Active   Covered    Misses % Covered
    ----------------        ------      ----    ------ ---------
    FEC Expression Terms         0         0         0     100.0
FSM Coverage:
    Enabled Coverage        Active      Hits    Misses % Covered
    ----------------        ------      ----    ------ ---------
    States                       0         0         0     100.0
    Transitions                  0         0         0     100.0
Toggle Coverage:
    Enabled Coverage        Active      Hits    Misses % Covered
    ----------------        ------      ----    ------ ---------
    Toggle Bins                162       146        16      90.1

================================Toggle Details================================

Toggle Coverage for File draw_octant.vhd --

       Line                                   Node      1H->0L      0L->1H                          "Coverage"
--------------------------------------------------------------------------------------------------------------
         14                                 yin(5)           1           1                              100.00 
         14                                 yin(4)           1           1                              100.00 
         14                                 yin(3)           1           1                              100.00 
         14                                 yin(2)           1           1                              100.00 
         14                                 yin(1)           1           1                              100.00 
         14                                 yin(0)           1           1                              100.00 
         14                                 xin(5)           1           1                              100.00 
         14                                 xin(4)           1           1                              100.00 
         14                                 xin(3)           1           1                              100.00 
         14                                 xin(2)           1           1                              100.00 
         14                                 xin(1)           1           1                              100.00 
         14                                 xin(0)           1           1                              100.00 
         16                                   y(5)           1           1                              100.00 
         16                                   y(4)           1           1                              100.00 
         16                                   y(3)           1           1                              100.00 
         16                                   y(2)           1           1                              100.00 
         16                                   y(1)           1           1                              100.00 
         16                                   y(0)           1           1                              100.00 
         16                                   x(5)           1           1                              100.00 
         16                                   x(4)           1           1                              100.00 
         16                                   x(3)           1           1                              100.00 
         16                                   x(2)           1           1                              100.00 
         16                                   x(1)           1           1                              100.00 
         16                                   x(0)           1           1                              100.00 
         22                                  done1           1           1                              100.00 
         23                                  y1(5)           1           1                              100.00 
         23                                  y1(4)           1           1                              100.00 
         23                                  y1(3)           1           1                              100.00 
         23                                  y1(2)           1           1                              100.00 
         23                                  y1(1)           1           1                              100.00 
         23                                  y1(0)           1           1                              100.00 
         23                                  x1(5)           1           1                              100.00 
         23                                  x1(4)           1           1                              100.00 
         23                                  x1(3)           1           1                              100.00 
         23                                  x1(2)           1           1                              100.00 
         23                                  x1(1)           1           1                              100.00 
         23                                  x1(0)           1           1                              100.00 
         24                                ynew(5)           1           1                              100.00 
         24                                ynew(4)           1           1                              100.00 
         24                                ynew(3)           1           1                              100.00 
         24                                ynew(2)           1           1                              100.00 
         24                                ynew(1)           1           1                              100.00 
         24                                ynew(0)           1           1                              100.00 
         24                               yincr(5)           0           0                                0.00 
         24                               yincr(4)           0           0                                0.00 
         24                               yincr(3)           1           1                              100.00 
         24                               yincr(2)           1           1                              100.00 
         24                               yincr(1)           1           1                              100.00 
         24                               yincr(0)           1           1                              100.00 
         24                                xnew(5)           1           1                              100.00 
         24                                xnew(4)           1           1                              100.00 
         24                                xnew(3)           1           1                              100.00 
         24                                xnew(2)           1           1                              100.00 
         24                                xnew(1)           1           1                              100.00 
         24                                xnew(0)           1           1                              100.00 
         24                               xincr(5)           0           0                                0.00 
         24                               xincr(4)           1           1                              100.00 
         24                               xincr(3)           1           1                              100.00 
         24                               xincr(2)           1           1                              100.00 
         24                               xincr(1)           1           1                              100.00 
         24                               xincr(0)           1           1                              100.00 
         28                               error(5)           1           1                              100.00 
         28                               error(4)           1           1                              100.00 
         28                               error(3)           1           1                              100.00 
         28                               error(2)           1           1                              100.00 
         28                               error(1)           1           1                              100.00 
         28                               error(0)           1           1                              100.00 
         29                                err2(6)           0           0                                0.00 
         29                                err2(5)           0           0                                0.00 
         29                                err2(4)           1           1                              100.00 
         29                                err2(3)           1           1                              100.00 
         29                                err2(2)           1           1                              100.00 
         29                                err2(1)           1           1                              100.00 
         29                                err2(0)           1           1                              100.00 
         29                                err1(6)           0           0                                0.00 
         29                                err1(5)           0           0                                0.00 
         29                                err1(4)           0           0                                0.00 
         29                                err1(3)           1           1                              100.00 
         29                                err1(2)           1           1                              100.00 
         29                                err1(1)           1           1                              100.00 
         29                                err1(0)           1           1                              100.00 

Total Node Count     =         81 
Toggled Node Count   =         73 
Untoggled Node Count =          8 

Toggle Coverage      =       90.1% (146 of 162 bins)

File: hdb.vhd
Statement Coverage:
    Enabled Coverage        Active      Hits    Misses % Covered
    ----------------        ------      ----    ------ ---------
    Stmts                      166       151        15      90.9

================================Statement Details================================

Statement Coverage for file hdb.vhd --

    1                                              --Last edited by Dominic Kwok at 6/3/2016
    2                                              
    3                                              
    4                                              library ieee;
    5                                              use ieee.std_logic_1164.all;
    6                                              use ieee.numeric_std.all;
    7                                              use work.project_pack.all;
    8                                              use work.all;
    9                                              
    10                                             entity db is
    11                                             	GENERIC(vsize : INTEGER := 6);
    12                                             	port(
    13                                             		clk          : in  std_logic;
    14                                             		instruction  : in  std_logic_vector(15 downto 0);
    15                                             		dav          : in  std_logic;
    16                                             		delaycmd     : in  std_logic;
    17                                             		reset        : in  std_logic;
    18                                             		hdb_bus      : out db_2_rcb;
    19                                             		hdb_busy_out : out std_logic;
    20                                             		db_finish    : out std_logic
    21                                             	);
    22                                             end entity db;
    23                                             
    24                                             architecture main of db is
    25                                             	alias lv is std_logic_vector;
    26                                             
    27                                             	--wire 
    28                                             	signal x_new    : lv(5 downto 0);
    29                                             	signal y_new    : lv(5 downto 0);
    30                                             	signal x_old    : lv(5 downto 0);
    31                                             	signal y_old    : lv(5 downto 0);
    32                                             	signal FSM_en   : std_logic;
    33                                             	signal x_out    : std_logic_vector(5 downto 0);
    34                                             	signal y_out    : std_logic_vector(5 downto 0);
    35                                             	signal rcbcmd   : std_logic_vector(2 downto 0);
    36                                             	signal startcmd : std_logic;
    37                                             	signal x_clear  : lv(5 downto 0);
    38                                             	signal y_clear  : lv(5 downto 0);
    39                                             
    40                                             	--draw_any_octant signal
    41                                             	signal swap       : std_logic;
    42                                             	signal xbias      : std_logic;
    43                                             	signal negx       : std_logic;
    44                                             	signal negy       : std_logic;
    45                                             	signal disable    : std_logic;
    46                                             	signal diff_x     : lv(6 downto 0);
    47                                             	signal diff_y     : lv(6 downto 0);
    48                                             	signal x_in_draw  : lv(5 downto 0);
    49                                             	signal y_in_draw  : lv(5 downto 0);
    50                                             	signal x_out_draw : lv(5 downto 0);
    51                                             	signal y_out_draw : lv(5 downto 0);
    52                                             
    53                                             	--Register 
    54                                             	signal xynewReg : lv(11 downto 0);
    55                                             	signal xyoldReg : lv(11 downto 0);
    56                                             	signal penReg   : hostpen_t;
    57                                             	signal opReg    : hostop_t;
    58                                             	signal regEn    : std_logic;
    59                                             
    60                                             	--FSM IO 
    61                                             	signal hdb_busy   : std_logic;
    62                                             	signal draw_done  : std_logic;
    63                                             	signal resetx     : std_logic;
    64                                             	signal draw       : std_logic;
    65                                             	signal SelDrawMux : std_logic;
    66                                             	signal SelOutMux  : lv(1 downto 0);
    67                                             	signal clear_cmd  : std_logic;
    68                                             
    69                                             	--FSM state
    70                                             	--state need to be expanded to include clear screen command
    71                                             	type state_t is (IDLE, DECODE, MOVE, DRAWDOT_init, DRAWDOT_do, DRAWLINE_startpt, DRAWLINE_endpt, DRAWLINE_wait, CLEAR_mov_init, CLEAR_mov, CLEAR_wait_init, ClEAR_wait);
    72                                             	signal state   : state_t;
    73                                             	signal n_state : state_t;
    74                                             
    75                                             begin
    76                                             
    77                                             	--wire 
    78            1                        246     	hdb_busy_out     <= hdb_busy;
    79            1                     189273     	regEn            <= dav and (not hdb_busy) and (not delaycmd);
    80            1                         89     	x_new            <= xynewReg(11 downto 6);
    81            1                         90     	y_new            <= xynewReg(5 downto 0);
    82            1                         88     	x_old            <= xyoldReg(11 downto 6);
    83            1                         89     	y_old            <= xyoldReg(5 downto 0);
    84            1                     189028     	FSM_en           <= dav and (not delaycmd);
    85            1                        605     	hdb_bus.X        <= x_out;
    86            1                        611     	hdb_bus.Y        <= y_out;
    87            1                        141     	hdb_bus.rcb_cmd  <= rcbcmd;
    88            1                        276     	hdb_bus.startcmd <= startcmd;
    89            1                        106     	diff_x           <= lv(signed(resize(unsigned(x_new), diff_x'length)) - signed(resize(unsigned(x_old), diff_x'length)));
    90            1                        106     	diff_y           <= lv(signed(resize(unsigned(y_new), diff_y'length)) - signed(resize(unsigned(y_old), diff_y'length)));
    91            1                     189273     	db_finish        <= (not delaycmd) and (not dav) and (not hdb_busy);
    92                                             	--rcbcmd combinational
    93            1                        240     	HostCmd2RcbCmd : process(penReg, opReg, clear_cmd, diff_x, diff_y)
    94                                             	begin
    95                                             		case penReg is
    96                                             			when NotUsed =>
    97            1                          2     				rcbcmd <= "100";
    98                                             
    99                                             			when White =>
    100                                            				case opReg is
    101                                            					when MovePen =>
    102           1                         84     						rcbcmd <= "100";
    103                                            					when Drawline =>
    104           1                    ***0***     						rcbcmd <= "001";
    105                                            					when ClearScreen =>
    106                                            						if unsigned(diff_x) = 0 and unsigned(diff_y) = 0 then
    107           1                          1     							rcbcmd <= "001";
    108                                            						else
    109                                            							if clear_cmd = '0' then
    110           1                         15     								rcbcmd <= "000";
    111                                            							else
    112           1                          5     								rcbcmd <= "101";
    113                                            							end if;
    114                                            						end if;
    115                                            					when Unused =>
    116           1                    ***0***     						rcbcmd <= "100";
    117                                            					when others =>
    118           1                    ***0***     						NULL;
    119                                            				end case;
    120                                            			when Black =>
    121                                            				case opReg is
    122                                            					when MovePen =>
    123           1                          2     						rcbcmd <= "100";
    124                                            					when Drawline =>
    125           1                         62     						rcbcmd <= "010";
    126                                            					when ClearScreen =>
    127                                            						if unsigned(diff_x) = 0 and unsigned(diff_y) = 0 then
    128           1                          1     							rcbcmd <= "010";
    129                                            						else
    130                                            							if clear_cmd = '0' then
    131           1                         28     								rcbcmd <= "000";
    132                                            							else
    133           1                          9     								rcbcmd <= "110";
    134                                            							end if;
    135                                            						end if;
    136                                            					when Unused =>
    137           1                    ***0***     						rcbcmd <= "100";
    138                                            					when others =>
    139           1                    ***0***     						NULL;
    140                                            				end case;
    141                                            			when Invert =>
    142                                            				case opReg is
    143                                            					when MovePen =>
    144           1                          1     						rcbcmd <= "100";
    145                                            					when Drawline =>
    146           1                          7     						rcbcmd <= "011";
    147                                            					when ClearScreen =>
    148                                            						if unsigned(diff_x) = 0 and unsigned(diff_y) = 0 then
    149           1                         12     							rcbcmd <= "011";
    150                                            						else
    151                                            							if clear_cmd = '0' then
    152           1                          9     								rcbcmd <= "000";
    153                                            							else
    154           1                    ***0***     								rcbcmd <= "111";
    155                                            							end if;
    156                                            						end if;
    157                                            					when Unused =>
    158           1                    ***0***     						rcbcmd <= "100";
    159                                            					when others =>
    160           1                    ***0***     						NULL;
    161                                            				end case;
    162                                            			when others =>
    163           1                          2     				NULL;
    164                                            		end case;
    165                                            	end process HostCmd2RcbCmd;
    166                                            
    167                                            	--register 
    168                                            	Reg : process
    169                                            	begin
    170                                            		wait until clk'event and clk = '1';
    171                                            		if reset = '0' then
    172           1                    2958375     			state <= n_state;
    173                                            			if regEn = '1' then
    174           1                        122     				xynewReg <= instruction(13 downto 2);
    175           1                        122     				xyoldReg <= xynewReg;
    176           1                        122     				penReg   <= instruction(1 downto 0);
    177           1                        122     				opReg    <= instruction(15 downto 14);
    178                                            			end if;
    179                                            		else
    180           1                         10     			state    <= IDLE;
    181           1                         10     			xynewReg <= (others => '0');
    182           1                         10     			xyoldReg <= (others => '0');
    183           1                         10     			penReg   <= (others => '0');
    184           1                         10     			opReg    <= (others => '0');
    185                                            		end if;
    186                                            	end process Reg;
    187                                            
    188                                            	--draw_any_octant
    189                                            	DAO : entity draw_any_octant generic map(x_new'length)
    190                                            		port map(clk, resetx, draw, xbias, disable, x_in_draw, y_in_draw, draw_done, x_out_draw, y_out_draw, swap, negx, negy);
    191                                            
    192                                            	--draw_any_octant Input Mux
    193           1                        210     	InMuxDraw : process(SelDrawMux, x_new, y_new, x_old, y_old)
    194                                            	begin
    195                                            		if SelDrawMux = '0' then
    196           1                        164     			x_in_draw <= x_old;
    197           1                        164     			y_in_draw <= y_old;
    198                                            		else
    199           1                         46     			x_in_draw <= x_new;
    200           1                         46     			y_in_draw <= y_new;
    201                                            		end if;
    202                                            	end process InMuxDraw;
    203                                            
    204                                            	--Output Mux
    205           1                       1011     	OutMux : process(x_new, y_new, x_old, y_old, x_out_draw, y_out_draw, x_clear, y_clear, SelOutMux)
    206                                            	begin
    207                                            		case SelOutMux is
    208                                            			when "00" =>
    209           1                        323     				x_out <= x_old;
    210           1                        323     				y_out <= y_old;
    211                                            			when "01" =>
    212           1                         63     				x_out <= x_new;
    213           1                         63     				y_out <= y_new;
    214                                            			when "10" =>
    215           1                        596     				x_out <= x_out_draw;
    216           1                        596     				y_out <= y_out_draw;
    217                                            			when "11" =>
    218           1                         28     				x_out <= x_clear;
    219           1                         28     				y_out <= y_clear;
    220           1                          1     			when others => NULL;
    221                                            		end case;
    222                                            	end process OutMux;
    223                                            
    224                                            	--logic that ensure left bottom corner is sent then right top corner later
    225           1                        148     	xyclear : process(clear_cmd, x_new, y_new, x_old, y_old)
    226                                            	begin
    227           1                        148     		(x_clear, y_clear) <= my_minmax((x_old, x_new, y_old, y_new), clear_cmd);
    228                                            	end process xyclear;
    229                                            
    230                                            	--FSM combinational
    231           1                     190801     	FSMcomb : process(state, delaycmd, draw_done,FSM_en,y_new,opreg,x_new,x_old,y_old)
    232                                            	begin
    233                                            		--default FSM output
    234                                            
    235           1                     190801     		draw       <= '0';
    236           1                     190801     		resetx     <= '0';
    237           1                     190801     		SelOutMux  <= "00";
    238           1                     190801     		SelDrawMux <= '0';
    239           1                     190801     		hdb_busy   <= '1';
    240           1                     190801     		startcmd   <= '0';
    241           1                     190801     		clear_cmd  <= '0';
    242                                            		
    243                                            		case state is
    244                                            			when IDLE =>
    245           1                     187688     				hdb_busy <= '0';
    246                                            				if FSM_en = '1' then
    247           1                        122     					n_state <= DECODE;
    248                                            				else
    249           1                     187566     					n_state <= IDLE;
    250                                            				end if;
    251                                            
    252                                            			when DECODE =>
    253                                            				case opReg is
    254                                            					when MovePen =>
    255           1                        135     						n_state <= MOVE;
    256                                            					when DrawLine =>
    257                                            						if (unsigned(x_new) = unsigned(x_old)) and (unsigned(y_new) = unsigned(y_old)) then
    258           1                         16     							n_state <= DRAWDOT_init;
    259                                            						else
    260           1                        130     							n_state <= DRAWLINE_startpt;
    261                                            						end if;
    262                                            					when ClearScreen =>
    263                                            						if (unsigned(x_new) = unsigned(x_old)) and (unsigned(y_new) = unsigned(y_old)) then
    264           1                         32     							n_state <= DRAWDOT_init;
    265                                            						else
    266           1                         52     							n_state <= CLEAR_mov_init;
    267                                            						end if;
    268           1                    ***0***     					when Unused => n_state<=idle;
    269           1                    ***0***     					when Others => NULL;
    270                                            				end case;
    271                                            
    272                                            			when MOVE =>
    273           1                         45     				SelOutMux <= "01";
    274           1                         45     				startcmd  <= '0';
    275           1                         45     				n_state <= IDLE;
    276                                            
    277                                            			when DRAWDOT_init =>
    278           1                         18     				SelOutMux <= "01";
    279           1                         18     				startcmd  <= '1';
    280                                            				if delaycmd = '0' then
    281           1                         18     					n_state <= DRAWDOT_do;
    282                                            				else
    283           1                    ***0***     					n_state <= DRAWDOT_init;
    284                                            				end if;
    285                                            
    286                                            			when DRAWDOT_do =>
    287           1                         90     				SelOutMux <= "01";
    288                                            
    289                                            				if delaycmd = '0' then
    290           1                         54     					n_state  <= IDLE;
    291           1                         54     					startcmd <= '0';
    292                                            				else
    293           1                         36     					n_state  <= DRAWDOT_do;
    294           1                         36     					startcmd <= '1';
    295                                            				end if;
    296                                            
    297                                            			when DRAWLINE_startpt =>
    298           1                         89     				resetx    <= '1';
    299           1                         89     				SelOutMux <= "10";
    300           1                         89     				startcmd  <= '0';
    301                                            				if delaycmd = '0' then
    302           1                         89     					n_state <= DRAWLINE_endpt;
    303                                            				else
    304           1                    ***0***     					n_state <= DRAWLINE_startpt;
    305                                            				end if;
    306                                            
    307                                            			when DRAWLINE_endpt =>
    308           1                         45     				draw       <= '1';
    309           1                         45     				SelOutMux  <= "10";
    310           1                         45     				SelDrawMux <= '1';
    311           1                         45     				startcmd   <= '1';
    312                                            				if delaycmd = '0' then
    313           1                         45     					n_state <= DRAWLINE_wait;
    314                                            				else
    315           1                    ***0***     					n_state <= DRAWLINE_endpt;
    316                                            				end if;
    317                                            
    318                                            			when DRAWLINE_wait =>
    319           1                       2293     				SelOutMux <= "10";
    320                                            
    321           1                       2293     				n_state <= IDLE;
    322                                            				if (delaycmd = '1') or (draw_done = '0') then
    323           1                       2204     					n_state  <= DRAWLINE_wait;
    324           1                       2204     					startcmd <= '1';
    325                                            				end if;
    326                                            
    327                                            			when CLEAR_mov_init =>
    328           1                         14     				SelOutMux <= "11";
    329           1                         14     				clear_cmd <= '0';
    330           1                         14     				startcmd  <= '1';
    331                                            				if delaycmd = '0' then
    332           1                         14     					n_state <= CLEAR_mov;
    333                                            				else
    334           1                    ***0***     					n_state <= CLEAR_mov_init;
    335                                            				end if;
    336                                            
    337                                            			when CLEAR_mov =>
    338           1                         70     				SelOutMux <= "11";
    339           1                         70     				clear_cmd <= '0';
    340                                            				if delaycmd = '0' then
    341           1                         42     					n_state  <= CLEAR_wait_init;
    342           1                         42     					startcmd <= '0';
    343                                            				else
    344           1                         28     					n_state  <= CLEAR_mov;
    345           1                         28     					startcmd <= '1';
    346                                            				end if;
    347                                            
    348                                            			when CLEAR_wait_init =>
    349           1                         14     				SelOutMux <= "11";
    350           1                         14     				startcmd  <= '1';
    351           1                         14     				clear_cmd <= '1';
    352                                            				if delaycmd = '0' then
    353           1                         14     					n_state <= ClEAR_wait;
    354                                            				else
    355           1                    ***0***     					n_state <= CLEAR_wait_init;
    356                                            				end if;
    357                                            
    358                                            			when CLEAR_wait =>
    359           1                         70     				SelOutMux <= "11";
    360           1                         70     				clear_cmd <= '1';
    361                                            				if delaycmd = '0' then
    362           1                         42     					startcmd <= '0';
    363           1                         42     					n_state  <= IDLE;
    364                                            				else
    365           1                         28     					startcmd <= '1';
    366           1                         28     					n_state  <= CLEAR_wait;
    367                                            				end if;
    368                                            
    369                                            		end case;
    370                                            	end process FSMcomb;
    371                                            
    372                                            	--Octant_CMB
    373           1                        106     	octantcomb : process( diff_x, diff_y)
    374                                            	begin
    375                                            		if to_integer(signed(diff_x)) < 0 then
    376                                            			--dx<0
    377                                            			if to_integer(signed(diff_y)) < 0 then
    378                                            				--dy<0
    379                                            				if abs (signed(diff_y)) > abs (signed(diff_x)) then
    380                                            					--SSW
    381           1                          8     					negx  <= '1';
    382           1                          8     					negy  <= '1';
    383           1                          8     					swap  <= '1';
    384           1                          8     					xbias <= '1';
    385                                            				else
    386                                            					--WSW
    387           1                         15     					negx  <= '1';
    388           1                         15     					negy  <= '1';
    389           1                         15     					swap  <= '0';
    390           1                         15     					xbias <= '1';
    391                                            				end if;
    392                                            			else
    393                                            				--dy>0
    394                                            				if abs (signed(diff_y)) > abs (signed(diff_x)) then
    395                                            					--NNW
    396           1                          4     					negx  <= '1';
    397           1                          4     					negy  <= '0';
    398           1                          4     					swap  <= '1';
    399           1                          4     					xbias <= '0';
    400                                            				else
    401                                            					--WNW
    402           1                         12     					negx  <= '1';
    403           1                         12     					negy  <= '0';
    404           1                         12     					swap  <= '0';
    405           1                         12     					xbias <= '0';
    406                                            				end if;
    407                                            			end if;
    408                                            		else
    409                                            			--dx>0
    410                                            			if to_integer(signed(diff_y)) < 0 then
    411                                            				--dy<0
    412                                            				if abs (signed(diff_y)) > abs (signed(diff_x)) then
    413                                            					--SSE
    414           1                          8     					negx  <= '0';
    415           1                          8     					negy  <= '1';
    416           1                          8     					swap  <= '1';
    417           1                          8     					xbias <= '0';
    418                                            				else
    419                                            					--ESE
    420           1                          9     					negx  <= '0';
    421           1                          9     					negy  <= '1';
    422           1                          9     					swap  <= '0';
    423           1                          9     					xbias <= '0';
    424                                            				end if;
    425                                            			else
    426                                            				--dy>0
    427                                            				if abs (signed(diff_y)) > abs (signed(diff_x)) then
    428                                            					--NNE
    429           1                         11     					negx  <= '0';
    430           1                         11     					negy  <= '0';
    431           1                         11     					swap  <= '1';
    432           1                         11     					xbias <= '1';
    433                                            				else
    434                                            					--ENE
    435           1                         39     					negx  <= '0';
    436           1                         39     					negy  <= '0';
    437           1                         39     					swap  <= '0';
    438           1                         39     					xbias <= '1';
    439                                            				end if;
    440                                            			end if;
    441                                            		end if;
    442                                            	end process octantcomb;
    443           1                     188784     	disable <= delaycmd;
    444                                            
    445                                            end architecture main;

Branch Coverage:
    Enabled Coverage        Active      Hits    Misses % Covered
    ----------------        ------      ----    ------ ---------
    Branches                    98        83        15      84.6

================================Branch Details================================

Branch Coverage for file hdb.vhd --

------------------------------------CASE Branch------------------------------------
    95                                     240     Count coming in to CASE
    96            1                          2     			when NotUsed =>
    99            1                        105     			when White =>
    120           1                        102     			when Black =>
    141           1                         29     			when Invert =>
    162           1                          2     			when others =>
Branch totals: 5 hits of 5 branches = 100.0%

------------------------------------CASE Branch------------------------------------
    100                                    105     Count coming in to CASE
    101           1                         84     					when MovePen =>
    103           1                    ***0***     					when Drawline =>
    105           1                         21     					when ClearScreen =>
    115           1                    ***0***     					when Unused =>
    117           1                    ***0***     					when others =>
Branch totals: 2 hits of 5 branches = 40.0%

------------------------------------IF Branch------------------------------------
    106                                     21     Count coming in to IF
    106           1                          1     						if unsigned(diff_x) = 0 and unsigned(diff_y) = 0 then
    108           1                         20     						else
Branch totals: 2 hits of 2 branches = 100.0%

------------------------------------IF Branch------------------------------------
    109                                     20     Count coming in to IF
    109           1                         15     							if clear_cmd = '0' then
    111           1                          5     							else
Branch totals: 2 hits of 2 branches = 100.0%

------------------------------------CASE Branch------------------------------------
    121                                    102     Count coming in to CASE
    122           1                          2     					when MovePen =>
    124           1                         62     					when Drawline =>
    126           1                         38     					when ClearScreen =>
    136           1                    ***0***     					when Unused =>
    138           1                    ***0***     					when others =>
Branch totals: 3 hits of 5 branches = 60.0%

------------------------------------IF Branch------------------------------------
    127                                     38     Count coming in to IF
    127           1                          1     						if unsigned(diff_x) = 0 and unsigned(diff_y) = 0 then
    129           1                         37     						else
Branch totals: 2 hits of 2 branches = 100.0%

------------------------------------IF Branch------------------------------------
    130                                     37     Count coming in to IF
    130           1                         28     							if clear_cmd = '0' then
    132           1                          9     							else
Branch totals: 2 hits of 2 branches = 100.0%

------------------------------------CASE Branch------------------------------------
    142                                     29     Count coming in to CASE
    143           1                          1     					when MovePen =>
    145           1                          7     					when Drawline =>
    147           1                         21     					when ClearScreen =>
    157           1                    ***0***     					when Unused =>
    159           1                    ***0***     					when others =>
Branch totals: 3 hits of 5 branches = 60.0%

------------------------------------IF Branch------------------------------------
    148                                     21     Count coming in to IF
    148           1                         12     						if unsigned(diff_x) = 0 and unsigned(diff_y) = 0 then
    150           1                          9     						else
Branch totals: 2 hits of 2 branches = 100.0%

------------------------------------IF Branch------------------------------------
    151                                      9     Count coming in to IF
    151           1                          9     							if clear_cmd = '0' then
    153           1                    ***0***     							else
Branch totals: 1 hit of 2 branches = 50.0%

------------------------------------IF Branch------------------------------------
    171                                2958385     Count coming in to IF
    171           1                    2958375     		if reset = '0' then
    179           1                         10     		else
Branch totals: 2 hits of 2 branches = 100.0%

------------------------------------IF Branch------------------------------------
    173                                2958375     Count coming in to IF
    173           1                        122     			if regEn = '1' then
                                       2958253     All False Count
Branch totals: 2 hits of 2 branches = 100.0%

------------------------------------IF Branch------------------------------------
    195                                    210     Count coming in to IF
    195           1                        164     		if SelDrawMux = '0' then
    198           1                         46     		else
Branch totals: 2 hits of 2 branches = 100.0%

------------------------------------CASE Branch------------------------------------
    207                                   1011     Count coming in to CASE
    208           1                        323     			when "00" =>
    211           1                         63     			when "01" =>
    214           1                        596     			when "10" =>
    217           1                         28     			when "11" =>
    220           1                          1     			when others => NULL;
Branch totals: 5 hits of 5 branches = 100.0%

------------------------------------CASE Branch------------------------------------
    243                                 190801     Count coming in to CASE
    244           1                     187688     			when IDLE =>
    252           1                        365     			when DECODE =>
    272           1                         45     			when MOVE =>
    277           1                         18     			when DRAWDOT_init =>
    286           1                         90     			when DRAWDOT_do =>
    297           1                         89     			when DRAWLINE_startpt =>
    307           1                         45     			when DRAWLINE_endpt =>
    318           1                       2293     			when DRAWLINE_wait =>
    327           1                         14     			when CLEAR_mov_init =>
    337           1                         70     			when CLEAR_mov =>
    348           1                         14     			when CLEAR_wait_init =>
    358           1                         70     			when CLEAR_wait =>
Branch totals: 12 hits of 12 branches = 100.0%

------------------------------------IF Branch------------------------------------
    246                                 187688     Count coming in to IF
    246           1                        122     				if FSM_en = '1' then
    248           1                     187566     				else
Branch totals: 2 hits of 2 branches = 100.0%

------------------------------------CASE Branch------------------------------------
    253                                    365     Count coming in to CASE
    254           1                        135     					when MovePen =>
    256           1                        146     					when DrawLine =>
    262           1                         84     					when ClearScreen =>
    268           1                    ***0***     					when Unused => n_state<=idle;
    269           1                    ***0***     					when Others => NULL;
Branch totals: 3 hits of 5 branches = 60.0%

------------------------------------IF Branch------------------------------------
    257                                    146     Count coming in to IF
    257           1                         16     						if (unsigned(x_new) = unsigned(x_old)) and (unsigned(y_new) = unsigned(y_old)) then
    259           1                        130     						else
Branch totals: 2 hits of 2 branches = 100.0%

------------------------------------IF Branch------------------------------------
    263                                     84     Count coming in to IF
    263           1                         32     						if (unsigned(x_new) = unsigned(x_old)) and (unsigned(y_new) = unsigned(y_old)) then
    265           1                         52     						else
Branch totals: 2 hits of 2 branches = 100.0%

------------------------------------IF Branch------------------------------------
    280                                     18     Count coming in to IF
    280           1                         18     				if delaycmd = '0' then
    282           1                    ***0***     				else
Branch totals: 1 hit of 2 branches = 50.0%

------------------------------------IF Branch------------------------------------
    289                                     90     Count coming in to IF
    289           1                         54     				if delaycmd = '0' then
    292           1                         36     				else
Branch totals: 2 hits of 2 branches = 100.0%

------------------------------------IF Branch------------------------------------
    301                                     89     Count coming in to IF
    301           1                         89     				if delaycmd = '0' then
    303           1                    ***0***     				else
Branch totals: 1 hit of 2 branches = 50.0%

------------------------------------IF Branch------------------------------------
    312                                     45     Count coming in to IF
    312           1                         45     				if delaycmd = '0' then
    314           1                    ***0***     				else
Branch totals: 1 hit of 2 branches = 50.0%

------------------------------------IF Branch------------------------------------
    322                                   2293     Count coming in to IF
    322           1                       2204     				if (delaycmd = '1') or (draw_done = '0') then
                                            89     All False Count
Branch totals: 2 hits of 2 branches = 100.0%

------------------------------------IF Branch------------------------------------
    331                                     14     Count coming in to IF
    331           1                         14     				if delaycmd = '0' then
    333           1                    ***0***     				else
Branch totals: 1 hit of 2 branches = 50.0%

------------------------------------IF Branch------------------------------------
    340                                     70     Count coming in to IF
    340           1                         42     				if delaycmd = '0' then
    343           1                         28     				else
Branch totals: 2 hits of 2 branches = 100.0%

------------------------------------IF Branch------------------------------------
    352                                     14     Count coming in to IF
    352           1                         14     				if delaycmd = '0' then
    354           1                    ***0***     				else
Branch totals: 1 hit of 2 branches = 50.0%

------------------------------------IF Branch------------------------------------
    361                                     70     Count coming in to IF
    361           1                         42     				if delaycmd = '0' then
    364           1                         28     				else
Branch totals: 2 hits of 2 branches = 100.0%

------------------------------------IF Branch------------------------------------
    375                                    106     Count coming in to IF
    375           1                         39     		if to_integer(signed(diff_x)) < 0 then
    408           1                         67     		else
Branch totals: 2 hits of 2 branches = 100.0%

------------------------------------IF Branch------------------------------------
    377                                     39     Count coming in to IF
    377           1                         23     			if to_integer(signed(diff_y)) < 0 then
    392           1                         16     			else
Branch totals: 2 hits of 2 branches = 100.0%

------------------------------------IF Branch------------------------------------
    379                                     23     Count coming in to IF
    379           1                          8     				if abs (signed(diff_y)) > abs (signed(diff_x)) then
    385           1                         15     				else
Branch totals: 2 hits of 2 branches = 100.0%

------------------------------------IF Branch------------------------------------
    394                                     16     Count coming in to IF
    394           1                          4     				if abs (signed(diff_y)) > abs (signed(diff_x)) then
    400           1                         12     				else
Branch totals: 2 hits of 2 branches = 100.0%

------------------------------------IF Branch------------------------------------
    410                                     67     Count coming in to IF
    410           1                         17     			if to_integer(signed(diff_y)) < 0 then
    425           1                         50     			else
Branch totals: 2 hits of 2 branches = 100.0%

------------------------------------IF Branch------------------------------------
    412                                     17     Count coming in to IF
    412           1                          8     				if abs (signed(diff_y)) > abs (signed(diff_x)) then
    418           1                          9     				else
Branch totals: 2 hits of 2 branches = 100.0%

------------------------------------IF Branch------------------------------------
    427                                     50     Count coming in to IF
    427           1                         11     				if abs (signed(diff_y)) > abs (signed(diff_x)) then
    433           1                         39     				else
Branch totals: 2 hits of 2 branches = 100.0%


Condition Coverage:
    Enabled Coverage        Active   Covered    Misses % Covered
    ----------------        ------      ----    ------ ---------
    FEC Condition Terms         12        11         1      91.6

================================Condition Details================================

Condition Coverage for file hdb.vhd --

----------------Focused Condition View-------------------
Line       106 Item    1 						if unsigned(diff_x) = 0 and unsigned(diff_y) = 0 then
Condition totals: 1 of 2 input terms covered = 50.0%

            Input Term   Covered  Reason for no coverage   Hint
           -----------  --------  -----------------------  --------------
  ((<type>)diff_x = 0)         Y
  ((<type>)diff_y = 0)         N  '_0' not hit             Hit '_0'

     Rows:       Hits  FEC Target              Matching input patterns       
 ---------  ---------  --------------------    -------------------------     
  Row   1:         20  ((<type>)diff_x = 0)_0  { 0- }                        
  Row   2:          1  ((<type>)diff_x = 0)_1  { 11 }                        
  Row   3:    ***0***  ((<type>)diff_y = 0)_0  { 10 }                        
  Row   4:          1  ((<type>)diff_y = 0)_1  { 11 }                        

NOTE:
  * Order of matching input pattern values: {((<type>)diff_x = 0),((<type>)diff_y = 0)}

----------------Focused Condition View-------------------
Line       127 Item    1 						if unsigned(diff_x) = 0 and unsigned(diff_y) = 0 then
Condition totals: 2 of 2 input terms covered = 100.0%

            Input Term   Covered  Reason for no coverage   Hint
           -----------  --------  -----------------------  --------------
  ((<type>)diff_x = 0)         Y
  ((<type>)diff_y = 0)         Y

     Rows:       Hits  FEC Target              Matching input patterns       
 ---------  ---------  --------------------    -------------------------     
  Row   1:         34  ((<type>)diff_x = 0)_0  { 0- }                        
  Row   2:          1  ((<type>)diff_x = 0)_1  { 11 }                        
  Row   3:          3  ((<type>)diff_y = 0)_0  { 10 }                        
  Row   4:          1  ((<type>)diff_y = 0)_1  { 11 }                        

NOTE:
  * Order of matching input pattern values: {((<type>)diff_x = 0),((<type>)diff_y = 0)}

----------------Focused Condition View-------------------
Line       148 Item    1 						if unsigned(diff_x) = 0 and unsigned(diff_y) = 0 then
Condition totals: 2 of 2 input terms covered = 100.0%

            Input Term   Covered  Reason for no coverage   Hint
           -----------  --------  -----------------------  --------------
  ((<type>)diff_x = 0)         Y
  ((<type>)diff_y = 0)         Y

     Rows:       Hits  FEC Target              Matching input patterns       
 ---------  ---------  --------------------    -------------------------     
  Row   1:          7  ((<type>)diff_x = 0)_0  { 0- }                        
  Row   2:         12  ((<type>)diff_x = 0)_1  { 11 }                        
  Row   3:          2  ((<type>)diff_y = 0)_0  { 10 }                        
  Row   4:         12  ((<type>)diff_y = 0)_1  { 11 }                        

NOTE:
  * Order of matching input pattern values: {((<type>)diff_x = 0),((<type>)diff_y = 0)}

----------------Focused Condition View-------------------
Line       257 Item    1 						if (unsigned(x_new) = unsigned(x_old)) and (unsigned(y_new) = unsigned(y_old)) then
Condition totals: 2 of 2 input terms covered = 100.0%

                       Input Term   Covered  Reason for no coverage   Hint
                      -----------  --------  -----------------------  --------------
  ((<type>)x_new = (<type>)x_old)         Y
  ((<type>)y_new = (<type>)y_old)         Y

     Rows:       Hits  FEC Target                         Matching input patterns       
 ---------  ---------  --------------------               -------------------------     
  Row   1:         95  ((<type>)x_new = (<type>)x_old)_0  { 0- }                        
  Row   2:         16  ((<type>)x_new = (<type>)x_old)_1  { 11 }                        
  Row   3:         35  ((<type>)y_new = (<type>)y_old)_0  { 10 }                        
  Row   4:         16  ((<type>)y_new = (<type>)y_old)_1  { 11 }                        

NOTE:
  * Order of matching input pattern values: {((<type>)x_new = (<type>)x_old),((<type>)y_new = (<type>)y_old)}

----------------Focused Condition View-------------------
Line       263 Item    1 						if (unsigned(x_new) = unsigned(x_old)) and (unsigned(y_new) = unsigned(y_old)) then
Condition totals: 2 of 2 input terms covered = 100.0%

                       Input Term   Covered  Reason for no coverage   Hint
                      -----------  --------  -----------------------  --------------
  ((<type>)x_new = (<type>)x_old)         Y
  ((<type>)y_new = (<type>)y_old)         Y

     Rows:       Hits  FEC Target                         Matching input patterns       
 ---------  ---------  --------------------               -------------------------     
  Row   1:         48  ((<type>)x_new = (<type>)x_old)_0  { 0- }                        
  Row   2:         32  ((<type>)x_new = (<type>)x_old)_1  { 11 }                        
  Row   3:          4  ((<type>)y_new = (<type>)y_old)_0  { 10 }                        
  Row   4:         32  ((<type>)y_new = (<type>)y_old)_1  { 11 }                        

NOTE:
  * Order of matching input pattern values: {((<type>)x_new = (<type>)x_old),((<type>)y_new = (<type>)y_old)}

----------------Focused Condition View-------------------
Line       322 Item    1 				if (delaycmd = '1') or (draw_done = '0') then
Condition totals: 2 of 2 input terms covered = 100.0%

         Input Term   Covered  Reason for no coverage   Hint
        -----------  --------  -----------------------  --------------
   (delaycmd = '1')         Y
  (draw_done = '0')         Y

     Rows:       Hits  FEC Target            Matching input patterns       
 ---------  ---------  --------------------  -------------------------     
  Row   1:         89  (delaycmd = '1')_0    { 00 }                        
  Row   2:       1124  (delaycmd = '1')_1    { 1- }                        
  Row   3:         89  (draw_done = '0')_0   { 00 }                        
  Row   4:       1080  (draw_done = '0')_1   { 01 }                        

NOTE:
  * Order of matching input pattern values: {(delaycmd = '1'),(draw_done = '0')}


Expression Coverage:
    Enabled Coverage        Active   Covered    Misses % Covered
    ----------------        ------      ----    ------ ---------
    FEC Expression Terms         8         7         1      87.5

================================Expression Details================================

Expression Coverage for file hdb.vhd --

----------------Focused Expression View-----------------
Line       79 Item    1 	regEn            <= dav and (not hdb_busy) and (not delaycmd);
Expression totals: 2 of 3 input terms covered = 66.6%

  Input Term   Covered  Reason for no coverage   Hint
 -----------  --------  -----------------------  --------------
         dav         Y
    hdb_busy         Y
    delaycmd         N  '_1' not hit             Hit '_1'

     Rows:       Hits  FEC Target            Matching input patterns       
 ---------  ---------  --------------------  -------------------------     
  Row   1:      93903  dav_0                 { 000 }                       
  Row   2:        122  dav_1                 { 100 }                       
  Row   3:        122  hdb_busy_0            { 100 }                       
  Row   4:        726  hdb_busy_1            { 110 }                       
  Row   5:        122  delaycmd_0            { 100 }                       
  Row   6:    ***0***  delaycmd_1            { 101 }                       

NOTE:
  * Order of matching input pattern values: {dav,hdb_busy,delaycmd}

----------------Focused Expression View-----------------
Line       84 Item    1 	FSM_en           <= dav and (not delaycmd);
Expression totals: 2 of 2 input terms covered = 100.0%

  Input Term   Covered  Reason for no coverage   Hint
 -----------  --------  -----------------------  --------------
         dav         Y
    delaycmd         Y

     Rows:       Hits  FEC Target            Matching input patterns       
 ---------  ---------  --------------------  -------------------------     
  Row   1:      93908  dav_0                 { 00 }                        
  Row   2:        727  dav_1                 { 10 }                        
  Row   3:        727  delaycmd_0            { 10 }                        
  Row   4:        605  delaycmd_1            { 11 }                        

NOTE:
  * Order of matching input pattern values: {dav,delaycmd}

----------------Focused Expression View-----------------
Line       91 Item    1 	db_finish        <= (not delaycmd) and (not dav) and (not hdb_busy);
Expression totals: 3 of 3 input terms covered = 100.0%

  Input Term   Covered  Reason for no coverage   Hint
 -----------  --------  -----------------------  --------------
    delaycmd         Y
         dav         Y
    hdb_busy         Y

     Rows:       Hits  FEC Target            Matching input patterns       
 ---------  ---------  --------------------  -------------------------     
  Row   1:      93903  delaycmd_0            { 000 }                       
  Row   2:      93780  delaycmd_1            { 100 }                       
  Row   3:      93903  dav_0                 { 000 }                       
  Row   4:        122  dav_1                 { 010 }                       
  Row   5:      93903  hdb_busy_0            { 000 }                       
  Row   6:        128  hdb_busy_1            { 001 }                       

NOTE:
  * Order of matching input pattern values: {delaycmd,dav,hdb_busy}


FSM Coverage:
    Enabled Coverage        Active      Hits    Misses % Covered
    ----------------        ------      ----    ------ ---------
    States                      12        12         0     100.0
    Transitions                 32        20        12      62.5

================================FSM Details================================

FSM Coverage for file hdb.vhd --

FSM_ID: state
    Current State Object : state
    ----------------------
    State Value MapInfo :
    ---------------------
Line          State Name               Value
----          ----------               -----
 244                IDLE                   0
 252              DECODE                   1
 327      CLEAR_mov_init                   8
 277        DRAWDOT_init                   3
 297    DRAWLINE_startpt                   5
 272                MOVE                   2
 286          DRAWDOT_do                   4
 307      DRAWLINE_endpt                   6
 318       DRAWLINE_wait                   7
 337           CLEAR_mov                   9
 348     CLEAR_wait_init                  10
 358          ClEAR_wait                  11
    Covered States :
    ----------------
                   State           Hit_count
                   -----           ---------
                    IDLE             2907335
                  DECODE                 122
          CLEAR_mov_init                  14
            DRAWDOT_init                  18
        DRAWLINE_startpt                  45
                    MOVE                  45
              DRAWDOT_do                  51
          DRAWLINE_endpt                  45
           DRAWLINE_wait                1955
               CLEAR_mov                  98
         CLEAR_wait_init                  14
              ClEAR_wait               48643
    Covered Transitions :
    ---------------------
Line            Trans_ID           Hit_count          Transition          
----            --------           ---------          ----------          
 247                   0                 122          IDLE -> DECODE      
 249                   1             2907213          IDLE -> IDLE        
 255                   2                  45          DECODE -> MOVE      
 258                   3                  18          DECODE -> DRAWDOT_init
 260                   4                  45          DECODE -> DRAWLINE_startpt
 266                   5                  14          DECODE -> CLEAR_mov_init
 332                   7                  14          CLEAR_mov_init -> CLEAR_mov
 281                  10                  18          DRAWDOT_init -> DRAWDOT_do
 302                  13                  45          DRAWLINE_startpt -> DRAWLINE_endpt
 275                  16                  45          MOVE -> IDLE        
 290                  17                  18          DRAWDOT_do -> IDLE  
 293                  18                  33          DRAWDOT_do -> DRAWDOT_do
 313                  19                  45          DRAWLINE_endpt -> DRAWLINE_wait
 321                  22                  45          DRAWLINE_wait -> IDLE
 323                  23                1910          DRAWLINE_wait -> DRAWLINE_wait
 341                  24                  14          CLEAR_mov -> CLEAR_wait_init
 344                  25                  84          CLEAR_mov -> CLEAR_mov
 353                  27                  14          CLEAR_wait_init -> ClEAR_wait
 363                  30                  14          ClEAR_wait -> IDLE  
 366                  31               48629          ClEAR_wait -> ClEAR_wait
    Uncovered Transitions :
    -----------------------
Line            Trans_ID          Transition          
----            --------          ----------          
 268                   6          DECODE -> IDLE      
 334                   8          CLEAR_mov_init -> CLEAR_mov_init
 180                   9          CLEAR_mov_init -> IDLE
 283                  11          DRAWDOT_init -> DRAWDOT_init
 180                  12          DRAWDOT_init -> IDLE
 304                  14          DRAWLINE_startpt -> DRAWLINE_startpt
 180                  15          DRAWLINE_startpt -> IDLE
 315                  20          DRAWLINE_endpt -> DRAWLINE_endpt
 180                  21          DRAWLINE_endpt -> IDLE
 180                  26          CLEAR_mov -> IDLE   
 355                  28          CLEAR_wait_init -> CLEAR_wait_init
 180                  29          CLEAR_wait_init -> IDLE


    Summary                 Active      Hits    Misses % Covered
    -------                 ------      ----    ------ ---------
    States                      12        12         0     100.0
    Transitions                 32        20        12      62.5

File: pix_cache_pak.vhd
Statement Coverage:
    Enabled Coverage        Active      Hits    Misses % Covered
    ----------------        ------      ----    ------ ---------
    Stmts                       12         0        12       0.0

================================Statement Details================================

Statement Coverage for file pix_cache_pak.vhd --

    1                                              LIBRARY IEEE;
    2                                              USE IEEE.std_logic_1164.ALL;
    3                                              
    4                                              -- This package contains types and constants for use by the pix_word_cache block
    5                                              -- pix_op_t is an array type used for the block ports, so this package must be
    6                                              -- used by any architecture instantiated pix_word_cache.
    7                                              
    8                                              -- Note that although the pixop_t array is similar to std_logic_vector(1 DOWNTO
    9                                              -- 0) the two cannot be directly assigned. In practice pixop_t will always be
    10                                             -- used via the constants defined in this package, with CASE statements to
    11                                             -- detect values or generate values as required.
    12                                             
    13                                             -- store_t is the array type based on pixop_t that stores pixel operations.
    14                                             -- Again it is used in a port of pix_word_cache, so architectures instantiating
    15                                             -- it will need to use this type.
    16                                             
    17                                             PACKAGE pix_cache_pak IS
    18                                             	TYPE pixop_t IS ARRAY (1 DOWNTO 0) OF std_logic;
    19                                             	SUBTYPE hostop_t is std_logic_vector(1 downto 0);
    20                                             	constant MovePen     : hostop_t := "00";
    21                                             	constant DrawLine    : hostop_t := "01";
    22                                             	constant ClearScreen : hostop_t := "10";
    23                                             	constant Unused      : hostop_t := "11";
    24                                             	CONSTANT psame       : pixop_t  := "00";
    25                                             	CONSTANT pblack      : pixop_t  := "10";
    26                                             	CONSTANT pwhite      : pixop_t  := "01";
    27                                             	CONSTANT pinvert     : pixop_t  := "11";
    28                                             	TYPE store_t IS ARRAY (0 TO 15) OF pixop_t;
    29                                             	function slv(input : pixop_t) return std_logic_vector;
    30                                             	function pixop(input : std_logic_vector(1 downto 0)) return pixop_t;
    31                                             END PACKAGE pix_cache_pak;
    32                                             
    33                                             package body pix_cache_pak is
    34                                             	function slv(input : pixop_t) return std_logic_vector is
    35                                             		variable result : std_logic_vector(1 downto 0);
    36                                             	begin
    37                                             		case input is
    38            1                    ***0***     			when psame   => result := "00";
    39            1                    ***0***     			when pblack  => result := "10";
    40            1                    ***0***     			when pwhite  => result := "01";
    41            1                    ***0***     			when pinvert => result := "11";
    42            1                    ***0***     			when others  => NULL;
    43                                             		end case;
    44            1                    ***0***     		return result;
    45                                             	end slv;
    46                                             
    47                                             	function pixop(input : std_logic_vector(1 downto 0)) return pixop_t is
    48                                             		variable result : pixop_t;
    49                                             	begin
    50                                             		case input is
    51            1                    ***0***     			when "00"   => result := psame;
    52            1                    ***0***     			when "10"   => result := pblack;
    53            1                    ***0***     			when "01"   => result := pwhite;
    54            1                    ***0***     			when "11"   => result := pinvert;
    55            1                    ***0***     			when others => NULL;
    56                                             		end case;
    57            1                    ***0***     		return result;
    58                                             	end pixop;
    59                                             end package body pix_cache_pak;

Branch Coverage:
    Enabled Coverage        Active      Hits    Misses % Covered
    ----------------        ------      ----    ------ ---------
    Branches                    10         0        10       0.0

================================Branch Details================================

Branch Coverage for file pix_cache_pak.vhd --

------------------------------------CASE Branch------------------------------------
    37                                 ***0***     Count coming in to CASE
    38            1                    ***0***     			when psame   => result := "00";
    39            1                    ***0***     			when pblack  => result := "10";
    40            1                    ***0***     			when pwhite  => result := "01";
    41            1                    ***0***     			when pinvert => result := "11";
    42            1                    ***0***     			when others  => NULL;
Branch totals: 0 hits of 5 branches = 0.0%

------------------------------------CASE Branch------------------------------------
    50                                 ***0***     Count coming in to CASE
    51            1                    ***0***     			when "00"   => result := psame;
    52            1                    ***0***     			when "10"   => result := pblack;
    53            1                    ***0***     			when "01"   => result := pwhite;
    54            1                    ***0***     			when "11"   => result := pinvert;
    55            1                    ***0***     			when others => NULL;
Branch totals: 0 hits of 5 branches = 0.0%


Condition Coverage:
    Enabled Coverage        Active   Covered    Misses % Covered
    ----------------        ------      ----    ------ ---------
    FEC Condition Terms          0         0         0     100.0
Expression Coverage:
    Enabled Coverage        Active   Covered    Misses % Covered
    ----------------        ------      ----    ------ ---------
    FEC Expression Terms         0         0         0     100.0
FSM Coverage:
    Enabled Coverage        Active      Hits    Misses % Covered
    ----------------        ------      ----    ------ ---------
    States                       0         0         0     100.0
    Transitions                  0         0         0     100.0
Toggle Coverage:
    Enabled Coverage        Active      Hits    Misses % Covered
    ----------------        ------      ----    ------ ---------
    Toggle Bins                  0         0         0     100.0

================================Toggle Details================================

Toggle Coverage for File pix_cache_pak.vhd --

       Line                                   Node      1H->0L      0L->1H                          "Coverage"
--------------------------------------------------------------------------------------------------------------

Total Node Count     =          0 
Toggled Node Count   =          0 
Untoggled Node Count =          0 

Toggle Coverage      =      100.0% (0 of 0 bins)

File: pix_word_cache.vhd
Statement Coverage:
    Enabled Coverage        Active      Hits    Misses % Covered
    ----------------        ------      ----    ------ ---------
    Stmts                       36        30         6      83.3

================================Statement Details================================

Statement Coverage for file pix_word_cache.vhd --

    1                                              LIBRARY IEEE;
    2                                              USE IEEE.std_logic_1164.ALL;
    3                                              USE IEEE.numeric_std.ALL;
    4                                              USE WORK.pix_cache_pak.ALL;
    5                                              
    6                                              ENTITY pix_word_cache IS
    7                                              	PORT(
    8                                              		clk, reset, wen_all, pw : IN  std_logic;
    9                                              		pixopin                 : IN  pixop_t;
    10                                             		pixnum                  : IN  std_logic_vector(3 downto 0);
    11                                             		store                   : OUT store_t;
    12                                             		is_same                 : OUT std_logic
    13                                             	);
    14                                             
    15                                             END ENTITY pix_word_cache;
    16                                             
    17                                             ARCHITECTURE func OF pix_word_cache IS
    18                                             	SIGNAL rdin1, rdout1 : pixop_t;
    19                                             	SIGNAL rdout_par     : store_t;
    20                                             	SIGNAL wen_concac    : std_logic_vector(1 DOWNTO 0);
    21                                             
    22                                             	ALIAS usgn IS unsigned;
    23                                             
    24                                             	--function has return value, procedure does not
    25                                             	--procedure ~ void
    26                                             
    27                                             	PROCEDURE write_ram(SIGNAL rdout_par : OUT store_t; comp_each : std_logic; index_in : INTEGER) IS
    28                                             	BEGIN
    29            1                      99396     		FOR i IN rdout_par'RANGE LOOP
    29            2                    1590336     
    30                                             			IF comp_each = '0' THEN     --if comp_each is 0, just write all
    31            1                    1590336     				rdout_par(i) <= psame;
    32                                             			ELSE
    33                                             				IF i /= index_in THEN
    34            1                    ***0***     					rdout_par(i) <= psame;
    35                                             				ELSE
    36            1                    ***0***     					rdout_par(i) <= rdin1;
    37                                             				END IF;
    38                                             			END IF;
    39            1                    1590336     		END LOOP;
    40                                             	END PROCEDURE write_ram;
    41                                             
    42                                             	FUNCTION check_same(rdout_par : store_t) RETURN std_logic IS
    43                                             	BEGIN
    44            1                      27684     		FOR i IN rdout_par'RANGE LOOP
    44            2                     220828     
    45                                             			IF rdout_par(i) /= psame THEN
    46            1                      22077     				RETURN '0';             --if not same, then break and return
    47                                             			END IF;
    48            1                     220828     		END LOOP;
    49                                             		--else all same
    50            1                       5607     		RETURN '1';
    51                                             	END FUNCTION check_same;
    52                                             
    53                                             BEGIN
    54            1                     249864     	CHANGE : PROCESS(pw, wen_all, rdout1, pixopin)
    55                                             	BEGIN
    56                                             		--rdout1 -> opram
    57                                             		--opout -> rdin1
    58                                             		IF wen_all = '0' THEN
    59                                             			CASE rdout1 IS
    60                                             				WHEN psame =>
    61            1                     122702     					rdin1 <= pixopin;
    62                                             				WHEN pblack =>
    63                                             					CASE pixopin(0) IS
    64                                             						WHEN '0' =>
    65            1                       2361     							rdin1 <= pblack;
    66                                             						WHEN '1' =>
    67            1                         25     							rdin1 <= pwhite;
    68            1                    ***0***     						WHEN OTHERS => NULL;
    69                                             					END CASE;
    70                                             				WHEN pwhite =>
    71                                             					CASE pixopin(1) IS
    72                                             						WHEN '0' =>
    73            1                      25296     							rdin1 <= pwhite;
    74                                             						WHEN '1' =>
    75            1                         39     							rdin1 <= pblack;
    76            1                    ***0***     						WHEN OTHERS => NULL;
    77                                             					END CASE;
    78                                             				WHEN pinvert =>
    79                                             					IF (pixopin(1) XOR pixopin(0)) = '1' THEN
    80            1                    ***0***     						rdin1 <= pixopin;
    81                                             					ELSIF (pixopin(0) = '0') THEN
    82            1                          3     						rdin1 <= pinvert;
    83                                             					ELSIF (pixopin(0) = '1') THEN
    84            1                         50     						rdin1 <= psame;
    85                                             					ELSE
    86            1                    ***0***     						NULL;
    87                                             					END IF;
    88            1                          1     				WHEN OTHERS => NULL;
    89                                             			END CASE;
    90                                             		ELSIF pw = '0' THEN
    91            1                      99386     			rdin1 <= psame;
    92                                             		ELSE
    93            1                          1     			rdin1 <= pixopin;
    94                                             		END IF;
    95                                             	END PROCESS CHANGE;
    96                                             
    97            1                     211102     	wen_concac <= wen_all & pw;
    98                                             
    99                                             	STORE_RAM : PROCESS
    100           1                          1     	BEGIN
    101                                            		--pixnum -> raddr1
    102           1                    2958386     		WAIT UNTIL rising_edge(clk);
    103                                            		IF reset = '1' THEN
    104           1                         10     			write_ram(rdout_par, '0', 0);
    105                                            		ELSE
    106                                            			IF wen_concac(1) = '1' THEN
    107           1                      99386     				write_ram(rdout_par, wen_concac(0), to_integer(usgn(pixnum)));
    108                                            			ELSIF wen_concac(0) = '1' THEN
    109           1                      22092     				rdout_par(to_integer(usgn(pixnum))) <= rdin1;
    110                                            			ELSE
    111           1                    2836897     				NULL;
    112                                            			END IF;
    113                                            		END IF;
    114                                            	END PROCESS STORE_RAM;
    115                                            
    116                                            	--propogate signal stuff
    117           1                      27684     	store   <= rdout_par;
    118           1                      27684     	is_same <= check_same(rdout_par);
    119           1                      49930     	rdout1  <= rdout_par(to_integer(usgn(pixnum)));
    120                                            
    121                                            END ARCHITECTURE func;

Branch Coverage:
    Enabled Coverage        Active      Hits    Misses % Covered
    ----------------        ------      ----    ------ ---------
    Branches                    29        22         7      75.8

================================Branch Details================================

Branch Coverage for file pix_word_cache.vhd --

------------------------------------IF Branch------------------------------------
    30                                 1590336     Count coming in to IF
    30            1                    1590336     			IF comp_each = '0' THEN     --if comp_each is 0, just write all
    32            1                    ***0***     			ELSE
Branch totals: 1 hit of 2 branches = 50.0%

------------------------------------IF Branch------------------------------------
    33                                 ***0***     Count coming in to IF
    33            1                    ***0***     				IF i /= index_in THEN
    35            1                    ***0***     				ELSE
Branch totals: 0 hits of 2 branches = 0.0%

------------------------------------IF Branch------------------------------------
    45                                  242905     Count coming in to IF
    45            1                      22077     			IF rdout_par(i) /= psame THEN
                                        220828     All False Count
Branch totals: 2 hits of 2 branches = 100.0%

------------------------------------IF Branch------------------------------------
    58                                  249864     Count coming in to IF
    58            1                     150477     		IF wen_all = '0' THEN
    90            1                      99386     		ELSIF pw = '0' THEN
    92            1                          1     		ELSE
Branch totals: 3 hits of 3 branches = 100.0%

------------------------------------CASE Branch------------------------------------
    59                                  150477     Count coming in to CASE
    60            1                     122702     				WHEN psame =>
    62            1                       2386     				WHEN pblack =>
    70            1                      25335     				WHEN pwhite =>
    78            1                         53     				WHEN pinvert =>
    88            1                          1     				WHEN OTHERS => NULL;
Branch totals: 5 hits of 5 branches = 100.0%

------------------------------------CASE Branch------------------------------------
    63                                    2386     Count coming in to CASE
    64            1                       2361     						WHEN '0' =>
    66            1                         25     						WHEN '1' =>
    68            1                    ***0***     						WHEN OTHERS => NULL;
Branch totals: 2 hits of 3 branches = 66.6%

------------------------------------CASE Branch------------------------------------
    71                                   25335     Count coming in to CASE
    72            1                      25296     						WHEN '0' =>
    74            1                         39     						WHEN '1' =>
    76            1                    ***0***     						WHEN OTHERS => NULL;
Branch totals: 2 hits of 3 branches = 66.6%

------------------------------------IF Branch------------------------------------
    79                                      53     Count coming in to IF
    79            1                    ***0***     					IF (pixopin(1) XOR pixopin(0)) = '1' THEN
    81            1                          3     					ELSIF (pixopin(0) = '0') THEN
    83            1                         50     					ELSIF (pixopin(0) = '1') THEN
    85            1                    ***0***     					ELSE
Branch totals: 2 hits of 4 branches = 50.0%

------------------------------------IF Branch------------------------------------
    103                                2958385     Count coming in to IF
    103           1                         10     		IF reset = '1' THEN
    105           1                    2958375     		ELSE
Branch totals: 2 hits of 2 branches = 100.0%

------------------------------------IF Branch------------------------------------
    106                                2958375     Count coming in to IF
    106           1                      99386     			IF wen_concac(1) = '1' THEN
    108           1                      22092     			ELSIF wen_concac(0) = '1' THEN
    110           1                    2836897     			ELSE
Branch totals: 3 hits of 3 branches = 100.0%


Condition Coverage:
    Enabled Coverage        Active   Covered    Misses % Covered
    ----------------        ------      ----    ------ ---------
    FEC Condition Terms          2         0         2       0.0

================================Condition Details================================

Condition Coverage for file pix_word_cache.vhd --

----------------Focused Condition View-------------------
Line       79 Item    1 					IF (pixopin(1) XOR pixopin(0)) = '1' THEN
Condition totals: 0 of 2 input terms covered = 0.0%

    Input Term   Covered  Reason for no coverage                  Hint
   -----------  --------  --------------------------------------  --------------
    pixopin(1)         N  Both rows hit for same output ->0      Hit either row for output ->1
    pixopin(0)         N  Both rows hit for same output ->0      Hit either row for output ->1

    Rows:   Hits(->0)   Hits(->1)  FEC Target            Matching input patterns(->0)         Matching input patterns(->1)
---------  ----------  ----------  --------------------  -----------------------------------  -----------------------------------
 Row   1:           3           0  pixopin(1)_0          { 00 }                               { 01 }
 Row   2:          50           0  pixopin(1)_1          { 11 }                               { 10 }
 Row   3:           3           0  pixopin(0)_0          { 00 }                               { 10 }
 Row   4:          50           0  pixopin(0)_1          { 11 }                               { 01 }

NOTE:
  * Order of matching input pattern values: {pixopin(1),pixopin(0)}


Expression Coverage:
    Enabled Coverage        Active   Covered    Misses % Covered
    ----------------        ------      ----    ------ ---------
    FEC Expression Terms         0         0         0     100.0
FSM Coverage:
    Enabled Coverage        Active      Hits    Misses % Covered
    ----------------        ------      ----    ------ ---------
    States                       0         0         0     100.0
    Transitions                  0         0         0     100.0
Toggle Coverage:
    Enabled Coverage        Active      Hits    Misses % Covered
    ----------------        ------      ----    ------ ---------
    Toggle Bins                 34        33         1      97.0

================================Toggle Details================================

Toggle Coverage for File pix_word_cache.vhd --

       Line                                   Node      1H->0L      0L->1H                          "Coverage"
--------------------------------------------------------------------------------------------------------------
          8                                wen_all           1           1                              100.00 
          8                                  reset           1           0                               50.00 
          8                                     pw           1           1                              100.00 
          8                                    clk           1           1                              100.00 
          9                             pixopin(1)           1           1                              100.00 
          9                             pixopin(0)           1           1                              100.00 
         10                              pixnum(3)           1           1                              100.00 
         10                              pixnum(2)           1           1                              100.00 
         10                              pixnum(1)           1           1                              100.00 
         10                              pixnum(0)           1           1                              100.00 
         12                                is_same           1           1                              100.00 
         18                              rdout1(1)           1           1                              100.00 
         18                              rdout1(0)           1           1                              100.00 
         18                               rdin1(1)           1           1                              100.00 
         18                               rdin1(0)           1           1                              100.00 
         20                          wen_concac(1)           1           1                              100.00 
         20                          wen_concac(0)           1           1                              100.00 

Total Node Count     =         17 
Toggled Node Count   =         16 
Untoggled Node Count =          1 

Toggle Coverage      =       97.0% (33 of 34 bins)

File: pix_write_cache.vhd
Statement Coverage:
    Enabled Coverage        Active      Hits    Misses % Covered
    ----------------        ------      ----    ------ ---------
    Stmts                       33        31         2      93.9

================================Statement Details================================

Statement Coverage for file pix_write_cache.vhd --

    1                                              LIBRARY ieee;
    2                                              USE IEEE.std_logic_1164.ALL;
    3                                              USE IEEE.numeric_std.ALL;
    4                                              USE work.project_pack.ALL;
    5                                              USE work.pix_cache_pak.ALL;
    6                                              
    7                                              ENTITY pix_write_cache IS
    8                                              	PORT(
    9                                              		clk, reset, start : IN  std_logic;
    10                                             		delay, vwrite     : OUT std_logic; --wait is a keyword, cannot be used
    11                                             		store             : IN  store_t;
    12                                             		addr              : IN  std_logic_vector(7 DOWNTO 0);
    13                                             		vaddr             : OUT std_logic_vector(7 DOWNTO 0);
    14                                             		vdout             : IN  std_logic_vector(RAM_WORD_SIZE - 1 DOWNTO 0);
    15                                             		vdin              : OUT std_logic_vector(RAM_WORD_SIZE - 1 DOWNTO 0)
    16                                             	);
    17                                             END ENTITY pix_write_cache;
    18                                             
    19                                             ARCHITECTURE memory_interface of pix_write_cache IS
    20                                             	ALIAS slv IS std_logic_vector;
    21                                             
    22                                             	TYPE state_t IS (m3, m2, m1, mx);
    23                                             	SIGNAL state, nstate : state_t;
    24                                             
    25                                             	SIGNAL reg_data : std_logic_vector(RAM_WORD_SIZE - 1 DOWNTO 0);
    26                                             	SIGNAL reg_addr : slv(7 DOWNTO 0);
    27                                             
    28                                             	SIGNAL vwrite_1, delay_1 : std_logic;
    29                                             
    30                                             BEGIN
    31                                             	R1 : PROCESS
    32            1                          1     	BEGIN
    33            1                    2958385     		WAIT UNTIL falling_edge(clk);
    34            1                    2958384     		reg_data <= vdout;
    35            1                    2958384     		reg_addr <= addr;
    36                                             	END PROCESS R1;
    37                                             
    38                                             	R2 : PROCESS
    39            1                          1     	BEGIN
    40            1                    2958386     		WAIT UNTIL rising_edge(clk);
    41                                             		IF reset = '1' THEN
    42            1                         10     			state <= mx;
    43                                             		ELSE
    44            1                    2958375     			state <= nstate;
    45                                             		END IF;
    46                                             	END PROCESS R2;
    47                                             
    48            1                     596319     	FSM : PROCESS(state, start)
    49                                             	BEGIN
    50            1                     596319     		vwrite_1 <= '0';
    51            1                     596319     		delay_1  <= '0';
    52                                             		CASE state IS
    53                                             			WHEN mx =>
    54                                             				IF start = '1' THEN
    55            1                      99386     					nstate <= m1;
    56                                             				ELSE
    57            1                      99387     					nstate <= mx;
    58                                             				END IF;
    59                                             			WHEN m1 =>
    60            1                     198772     				delay_1 <= start;
    61            1                     198772     				nstate  <= m2;
    62                                             			WHEN m2 =>
    63            1                      99386     				delay_1 <= start;
    64            1                      99386     				nstate  <= m3;
    65                                             			WHEN m3 =>
    66                                             				IF start = '1' THEN
    67            1                    ***0***     					nstate <= m1;
    68                                             				ELSE
    69            1                      99388     					nstate <= mx;
    70                                             				END IF;
    71            1                      99388     				vwrite_1 <= '1';
    72            1                    ***0***     			WHEN OTHERS => NULL;
    73                                             		END CASE;
    74                                             	END PROCESS FSM;
    75            1                      12835     DO_OP: process (store,reg_data) begin
    76            1                      12835     	FOR i IN vdin'RANGE LOOP
    76            2                     205360     
    77                                             		CASE store(i) IS
    78            1                     155448     			WHEN psame   => vdin(i) <= reg_data(i);
    79            1                      44331     			WHEN pwhite  => vdin(i) <= '0';
    80            1                       5477     			WHEN pblack  => vdin(i) <= '1';
    81            1                         88     			WHEN pinvert => vdin(i) <= (NOT reg_data(i));
    82            1                         16     			WHEN OTHERS  => NULL;
    83                                             		END CASE;
    84            1                     205360     	END LOOP;
    85                                             end process DO_OP;
    86            1                       5608     	vaddr<=reg_addr;
    87            1                     198775     	vwrite <= vwrite_1;
    88            1                     198774     	delay  <= delay_1;
    89                                             
    90                                             END ARCHITECTURE memory_interface;

Branch Coverage:
    Enabled Coverage        Active      Hits    Misses % Covered
    ----------------        ------      ----    ------ ---------
    Branches                    16        14         2      87.5

================================Branch Details================================

Branch Coverage for file pix_write_cache.vhd --

------------------------------------IF Branch------------------------------------
    41                                 2958385     Count coming in to IF
    41            1                         10     		IF reset = '1' THEN
    43            1                    2958375     		ELSE
Branch totals: 2 hits of 2 branches = 100.0%

------------------------------------CASE Branch------------------------------------
    52                                  596319     Count coming in to CASE
    53            1                     198773     			WHEN mx =>
    59            1                     198772     			WHEN m1 =>
    62            1                      99386     			WHEN m2 =>
    65            1                      99388     			WHEN m3 =>
    72            1                    ***0***     			WHEN OTHERS => NULL;
Branch totals: 4 hits of 5 branches = 80.0%

------------------------------------IF Branch------------------------------------
    54                                  198773     Count coming in to IF
    54            1                      99386     				IF start = '1' THEN
    56            1                      99387     				ELSE
Branch totals: 2 hits of 2 branches = 100.0%

------------------------------------IF Branch------------------------------------
    66                                   99388     Count coming in to IF
    66            1                    ***0***     				IF start = '1' THEN
    68            1                      99388     				ELSE
Branch totals: 1 hit of 2 branches = 50.0%

------------------------------------CASE Branch------------------------------------
    77                                  205360     Count coming in to CASE
    78            1                     155448     			WHEN psame   => vdin(i) <= reg_data(i);
    79            1                      44331     			WHEN pwhite  => vdin(i) <= '0';
    80            1                       5477     			WHEN pblack  => vdin(i) <= '1';
    81            1                         88     			WHEN pinvert => vdin(i) <= (NOT reg_data(i));
    82            1                         16     			WHEN OTHERS  => NULL;
Branch totals: 5 hits of 5 branches = 100.0%


Condition Coverage:
    Enabled Coverage        Active   Covered    Misses % Covered
    ----------------        ------      ----    ------ ---------
    FEC Condition Terms          0         0         0     100.0
Expression Coverage:
    Enabled Coverage        Active   Covered    Misses % Covered
    ----------------        ------      ----    ------ ---------
    FEC Expression Terms         0         0         0     100.0
FSM Coverage:
    Enabled Coverage        Active      Hits    Misses % Covered
    ----------------        ------      ----    ------ ---------
    States                       4         4         0     100.0
    Transitions                  8         5         3      62.5

================================FSM Details================================

FSM Coverage for file pix_write_cache.vhd --

FSM_ID: state
    Current State Object : state
    ----------------------
    State Value MapInfo :
    ---------------------
Line          State Name               Value
----          ----------               -----
  53                  mx                   3
  59                  m1                   2
  62                  m2                   1
  65                  m3                   0
    Covered States :
    ----------------
                   State           Hit_count
                   -----           ---------
                      mx             2660227
                      m1               99386
                      m2               99386
                      m3               99386
    Covered Transitions :
    ---------------------
Line            Trans_ID           Hit_count          Transition          
----            --------           ---------          ----------          
  55                   0               99386          mx -> m1            
  57                   1             2560840          mx -> mx            
  61                   2               99386          m1 -> m2            
  64                   4               99386          m2 -> m3            
  69                   7               99387          m3 -> mx            
    Uncovered Transitions :
    -----------------------
Line            Trans_ID          Transition          
----            --------          ----------          
  42                   3          m1 -> mx            
  42                   5          m2 -> mx            
  67                   6          m3 -> m1            


    Summary                 Active      Hits    Misses % Covered
    -------                 ------      ----    ------ ---------
    States                       4         4         0     100.0
    Transitions                  8         5         3      62.5
Toggle Coverage:
    Enabled Coverage        Active      Hits    Misses % Covered
    ----------------        ------      ----    ------ ---------
    Toggle Bins                124       122         2      98.3

================================Toggle Details================================

Toggle Coverage for File pix_write_cache.vhd --

       Line                                   Node      1H->0L      0L->1H                          "Coverage"
--------------------------------------------------------------------------------------------------------------
         12                                addr(7)           1           1                              100.00 
         12                                addr(6)           1           1                              100.00 
         12                                addr(5)           1           1                              100.00 
         12                                addr(4)           1           1                              100.00 
         12                                addr(3)           1           1                              100.00 
         12                                addr(2)           1           1                              100.00 
         12                                addr(1)           1           1                              100.00 
         12                                addr(0)           1           1                              100.00 
         13                               vaddr(7)           1           1                              100.00 
         13                               vaddr(6)           1           1                              100.00 
         13                               vaddr(5)           1           1                              100.00 
         13                               vaddr(4)           1           1                              100.00 
         13                               vaddr(3)           1           1                              100.00 
         13                               vaddr(2)           1           1                              100.00 
         13                               vaddr(1)           1           1                              100.00 
         13                               vaddr(0)           1           1                              100.00 
         14                               vdout(9)           1           1                              100.00 
         14                               vdout(8)           1           1                              100.00 
         14                               vdout(7)           1           1                              100.00 
         14                               vdout(6)           1           1                              100.00 
         14                               vdout(5)           1           1                              100.00 
         14                               vdout(4)           1           1                              100.00 
         14                               vdout(3)           1           1                              100.00 
         14                               vdout(2)           1           1                              100.00 
         14                              vdout(15)           1           1                              100.00 
         14                              vdout(14)           1           1                              100.00 
         14                              vdout(13)           1           1                              100.00 
         14                              vdout(12)           1           1                              100.00 
         14                              vdout(11)           1           1                              100.00 
         14                              vdout(10)           1           1                              100.00 
         14                               vdout(1)           1           1                              100.00 
         14                               vdout(0)           1           1                              100.00 
         23                                  state               ENUM type       Value       Count 
                                                                        m3           1      100.00 
                                                                        m2           1      100.00 
                                                                        m1           1      100.00 
                                                                        mx           1      100.00 
         23                                 nstate               ENUM type       Value       Count 
                                                                        m3           1      100.00 
                                                                        m2           1      100.00 
                                                                        m1           1      100.00 
                                                                        mx           1      100.00 
         25                            reg_data(9)           1           1                              100.00 
         25                            reg_data(8)           1           1                              100.00 
         25                            reg_data(7)           1           1                              100.00 
         25                            reg_data(6)           1           1                              100.00 
         25                            reg_data(5)           1           1                              100.00 
         25                            reg_data(4)           1           1                              100.00 
         25                            reg_data(3)           1           1                              100.00 
         25                            reg_data(2)           1           1                              100.00 
         25                           reg_data(15)           1           1                              100.00 
         25                           reg_data(14)           1           1                              100.00 
         25                           reg_data(13)           1           1                              100.00 
         25                           reg_data(12)           1           1                              100.00 
         25                           reg_data(11)           1           1                              100.00 
         25                           reg_data(10)           1           1                              100.00 
         25                            reg_data(1)           1           1                              100.00 
         25                            reg_data(0)           1           1                              100.00 
         26                            reg_addr(7)           1           1                              100.00 
         26                            reg_addr(6)           1           1                              100.00 
         26                            reg_addr(5)           1           1                              100.00 
         26                            reg_addr(4)           1           1                              100.00 
         26                            reg_addr(3)           1           1                              100.00 
         26                            reg_addr(2)           1           1                              100.00 
         26                            reg_addr(1)           1           1                              100.00 
         26                            reg_addr(0)           1           1                              100.00 
         28                               vwrite_1           1           1                              100.00 
         28                                delay_1           0           0                                0.00 

Total Node Count     =         66 
Toggled Node Count   =         65 
Untoggled Node Count =          1 

Toggle Coverage      =       98.3% (122 of 124 bins)

File: project_pack.vhd
Statement Coverage:
    Enabled Coverage        Active      Hits    Misses % Covered
    ----------------        ------      ----    ------ ---------
    Stmts                       13        10         3      76.9

================================Statement Details================================

Statement Coverage for file project_pack.vhd --

    1                                              USE WORK.config_pack.ALL;
    2                                              USE work.pix_cache_pak.ALL;
    3                                              LIBRARY IEEE;
    4                                              USE IEEE.std_logic_1164.ALL;
    5                                              USE IEEE.numeric_std.ALL;
    6                                              
    7                                              PACKAGE project_pack IS
    8                                              	CONSTANT RAM_WORD_SIZE : INTEGER := 16; -- fixed for this project could be changed by other applications
    9                                              
    10                                             	SUBTYPE hostop_t is std_logic_vector(1 downto 0);
    11                                             	SUBTYPE hostpen_t is std_logic_vector(1 downto 0);
    12                                             	SUBTYPE rcb_cmd_t IS std_logic_vector(2 DOWNTO 0);
    13                                             
    14                                             	constant MovePen     : hostop_t := "00";
    15                                             	constant DrawLine    : hostop_t := "01";
    16                                             	constant ClearScreen : hostop_t := "10";
    17                                             	constant Unused      : hostop_t := "11";
    18                                             
    19                                             	constant Notused : hostpen_t := "00";
    20                                             	constant White   : hostpen_t := "01";
    21                                             	constant Black   : hostpen_t := "10";
    22                                             	constant Invert  : hostpen_t := "11";
    23                                             
    24                                             	CONSTANT rcb_unused       : rcb_cmd_t := "100";
    25                                             	CONSTANT rcb_draw_white   : rcb_cmd_t := "001";
    26                                             	CONSTANT rcb_draw_black   : rcb_cmd_t := "010";
    27                                             	CONSTANT rcb_draw_invert  : rcb_cmd_t := "011";
    28                                             	CONSTANT rcb_move         : rcb_cmd_t := "000";
    29                                             	CONSTANT rcb_clear_white  : rcb_cmd_t := "101";
    30                                             	CONSTANT rcb_clear_black  : rcb_cmd_t := "110";
    31                                             	CONSTANT rcb_clear_invert : rcb_cmd_t := "111";
    32                                             
    33                                             	CONSTANT rcb_flush_latency          : INTEGER := 30;
    34                                             	CONSTANT rcb_flush_latency_slv_size : INTEGER := 8;
    35                                             
    36                                             	TYPE db_2_rcb IS RECORD             -- possible type for interface from DB to RCD. Change as required
    37                                             		X, Y     : std_logic_vector(VSIZE - 1 DOWNTO 0);
    38                                             		rcb_cmd  : std_logic_vector(2 DOWNTO 0);
    39                                             		startcmd : std_logic;
    40                                             	END RECORD;
    41                                             
    42                                             	TYPE my_xy IS RECORD
    43                                             		x1, x2, y1, y2 : std_logic_vector(VSIZE - 1 DOWNTO 0);
    44                                             	END RECORD;
    45                                             	TYPE my_xy_out IS RECORD
    46                                             		xout, yout : std_logic_vector(VSIZE - 1 DOWNTO 0);
    47                                             	END RECORD;
    48                                             
    49                                             	TYPE control IS RECORD
    50                                             		swapxy, negx, negy : std_logic;
    51                                             	END RECORD;
    52                                             
    53                                             	--function that apply operation onto a pixel word with width 16
    54                                             	FUNCTION my_minmax(i : my_xy; max : std_logic) RETURN my_xy_out;
    55                                             
    56                                             END PACKAGE project_pack;
    57                                             
    58                                             package body project_pack is
    59                                             
    60                                             
    61                                             	FUNCTION my_minmax(i : my_xy; max : std_logic) RETURN my_xy_out IS
    62                                             		VARIABLE tmp : std_logic_vector(1 DOWNTO 0) := "00";
    63                                             	BEGIN
    64                                             		IF unsigned(i.x2) < unsigned(i.x1) THEN
    65            1                         51     			tmp(1) := '1';
    66                                             		END IF;
    67                                             		IF unsigned(i.y2) < unsigned(i.y1) THEN
    68            1                         51     			tmp(0) := '1';
    69                                             		END IF;
    70                                             		IF max = '1' THEN
    71                                             			CASE (tmp) IS
    72            1                          8     				WHEN "00"   => RETURN (i.x2, i.y2);
    73            1                          2     				WHEN "01"   => RETURN (i.x2, i.y1);
    74            1                          2     				WHEN "10"   => RETURN (i.x1, i.y2);
    75            1                          2     				WHEN "11"   => RETURN (i.x1, i.y1);
    76            1                    ***0***     				WHEN OTHERS => NULL;
    77                                             			END CASE;
    78                                             		ELSE
    79                                             			CASE (tmp) IS
    80            1                         65     				WHEN "00"   => RETURN (i.x1, i.y1);
    81            1                         22     				WHEN "01"   => RETURN (i.x1, i.y2);
    82            1                         22     				WHEN "10"   => RETURN (i.x2, i.y1);
    83            1                         25     				WHEN "11"   => RETURN (i.x2, i.y2);
    84            1                    ***0***     				WHEN OTHERS => NULL;
    85                                             			END CASE;
    86                                             		END IF;
    87            1                    ***0***     		RETURN (i.x1, i.y1);
    88                                             	END FUNCTION my_minmax;
    89                                             
    90                                             end project_pack;

Branch Coverage:
    Enabled Coverage        Active      Hits    Misses % Covered
    ----------------        ------      ----    ------ ---------
    Branches                    16        14         2      87.5

================================Branch Details================================

Branch Coverage for file project_pack.vhd --

------------------------------------IF Branch------------------------------------
    64                                     148     Count coming in to IF
    64            1                         51     		IF unsigned(i.x2) < unsigned(i.x1) THEN
                                            97     All False Count
Branch totals: 2 hits of 2 branches = 100.0%

------------------------------------IF Branch------------------------------------
    67                                     148     Count coming in to IF
    67            1                         51     		IF unsigned(i.y2) < unsigned(i.y1) THEN
                                            97     All False Count
Branch totals: 2 hits of 2 branches = 100.0%

------------------------------------IF Branch------------------------------------
    70                                     148     Count coming in to IF
    70            1                         14     		IF max = '1' THEN
    78            1                        134     		ELSE
Branch totals: 2 hits of 2 branches = 100.0%

------------------------------------CASE Branch------------------------------------
    71                                      14     Count coming in to CASE
    72            1                          8     				WHEN "00"   => RETURN (i.x2, i.y2);
    73            1                          2     				WHEN "01"   => RETURN (i.x2, i.y1);
    74            1                          2     				WHEN "10"   => RETURN (i.x1, i.y2);
    75            1                          2     				WHEN "11"   => RETURN (i.x1, i.y1);
    76            1                    ***0***     				WHEN OTHERS => NULL;
Branch totals: 4 hits of 5 branches = 80.0%

------------------------------------CASE Branch------------------------------------
    79                                     134     Count coming in to CASE
    80            1                         65     				WHEN "00"   => RETURN (i.x1, i.y1);
    81            1                         22     				WHEN "01"   => RETURN (i.x1, i.y2);
    82            1                         22     				WHEN "10"   => RETURN (i.x2, i.y1);
    83            1                         25     				WHEN "11"   => RETURN (i.x2, i.y2);
    84            1                    ***0***     				WHEN OTHERS => NULL;
Branch totals: 4 hits of 5 branches = 80.0%


Condition Coverage:
    Enabled Coverage        Active   Covered    Misses % Covered
    ----------------        ------      ----    ------ ---------
    FEC Condition Terms          0         0         0     100.0
Expression Coverage:
    Enabled Coverage        Active   Covered    Misses % Covered
    ----------------        ------      ----    ------ ---------
    FEC Expression Terms         0         0         0     100.0
FSM Coverage:
    Enabled Coverage        Active      Hits    Misses % Covered
    ----------------        ------      ----    ------ ---------
    States                       0         0         0     100.0
    Transitions                  0         0         0     100.0
Toggle Coverage:
    Enabled Coverage        Active      Hits    Misses % Covered
    ----------------        ------      ----    ------ ---------
    Toggle Bins                  0         0         0     100.0

================================Toggle Details================================

Toggle Coverage for File project_pack.vhd --

       Line                                   Node      1H->0L      0L->1H                          "Coverage"
--------------------------------------------------------------------------------------------------------------

Total Node Count     =          0 
Toggled Node Count   =          0 
Untoggled Node Count =          0 

Toggle Coverage      =      100.0% (0 of 0 bins)

File: rcb.vhd
Statement Coverage:
    Enabled Coverage        Active      Hits    Misses % Covered
    ----------------        ------      ----    ------ ---------
    Stmts                       98        94         4      95.9

================================Statement Details================================

Statement Coverage for file rcb.vhd --

    1                                              LIBRARY ieee;
    2                                              USE IEEE.std_logic_1164.ALL;
    3                                              USE IEEE.numeric_std.ALL;
    4                                              USE work.project_pack.ALL;
    5                                              USE work.pix_cache_pak.ALL;
    6                                              USE work.pix_write_cache;
    7                                              USE work.pix_word_cache;
    8                                              use work.all;
    9                                              
    10                                             ENTITY rcb IS
    11                                             	GENERIC(vsize : INTEGER := 6);
    12                                             	PORT(
    13                                             		clk          : IN  std_logic;
    14                                             		reset        : IN  std_logic;
    15                                             
    16                                             		-- db connections
    17                                             		dbb_bus      : IN  db_2_rcb;
    18                                             		dbb_delaycmd : OUT STD_LOGIC;
    19                                             
    20                                             		-- vram connections
    21                                             		vdout        : IN  STD_LOGIC_VECTOR(15 DOWNTO 0);
    22                                             		vdin         : OUT STD_LOGIC_VECTOR(15 DOWNTO 0);
    23                                             		vwrite       : OUT STD_LOGIC;
    24                                             		vaddr        : OUT STD_LOGIC_VECTOR(7 DOWNTO 0);
    25                                             
    26                                             		-- vdp connection
    27                                             		rcb_finish   : OUT STD_LOGIC
    28                                             	);
    29                                             END rcb;
    30                                             
    31                                             ARCHITECTURE rtl1 OF rcb IS
    32                                             	ALIAS slv IS std_logic_vector;
    33                                             	ALIAS usgn IS unsigned;
    34                                             	--output
    35                                             	SIGNAL rcb_finish_1 : std_logic;
    36                                             
    37                                             	--wire
    38                                             	SIGNAL x_in            : slv(vsize - 1 DOWNTO 0);
    39                                             	SIGNAL y_in            : slv(vsize - 1 DOWNTO 0);
    40                                             	SIGNAL equal_block_out : std_logic;
    41                                             	SIGNAL split_word_addr : slv(7 DOWNTO 0);
    42                                             
    43                                             	--Register 
    44                                             	SIGNAL word_reg_out  : slv(7 DOWNTO 0);
    45                                             	SIGNAL x_clear_reg   : slv(vsize - 1 DOWNTO 0);
    46                                             	SIGNAL y_clear_reg   : slv(vsize - 1 DOWNTO 0);
    47                                             	SIGNAL x_clear_start : slv(vsize - 1 DOWNTO 0);
    48                                             	SIGNAL y_clear_start : slv(vsize - 1 DOWNTO 0);
    49                                             	SIGNAL pixop_reg     : store_t;
    50                                             
    51                                             	--Register enable
    52                                             	SIGNAL clear_reg_en : std_logic;
    53                                             	signal word_reg_en  : std_logic;
    54                                             	signal pixop_reg_en : std_logic;
    55                                             
    56                                             	--Clear counter control signal
    57                                             	signal diff_x    : slv(5 downto 0);
    58                                             	signal diff_y    : slv(5 downto 0);
    59                                             	signal clear_run : std_logic;
    60                                             
    61                                             	--rcb FSM
    62                                             	TYPE rcb_state_t IS (idle, move, flush_init, flush_done, draw, clear);
    63                                             	SIGNAL rcb_state, nstate   : rcb_state_t;
    64                                             	SIGNAL rcb_flush_downcount : slv(rcb_flush_latency_slv_size - 1 DOWNTO 0);
    65                                             	SIGNAL rcb_ready           : std_logic;
    66                                             	SIGNAL rcb_skip_pw         : std_logic;
    67                                             
    68                                             	--rmw FSM handshake SIGNAL
    69                                             	SIGNAL rmw_start  : std_logic;
    70                                             	SIGNAL rmw_delay  : std_logic;
    71                                             	SIGNAL rmw_vwrite : std_logic;
    72                                             
    73                                             	--pix_word_cache stuff
    74                                             	SIGNAL wen_all, pw : std_logic;
    75                                             	SIGNAL pixopin     : pixop_t;
    76                                             	SIGNAL pixnum      : slv(3 DOWNTO 0);
    77                                             	SIGNAL is_same     : std_logic;
    78                                             	SIGNAL store       : store_t;
    79                                             
    80                                             BEGIN
    81                                             
    82                                             	--wire assignment 
    83                                             	--assert rcb_finish when block is inactive and waiting
    84                                             	--no pixel write
    85                                             	--pix ram cache is empty
    86                                             	--ram inactive
    87            1                     188784     	dbb_delaycmd <= NOT rcb_ready;
    88            1                     187560     	rcb_finish   <= rcb_finish_1;
    89            1                      22092     	diff_x       <= slv(usgn(dbb_bus.x) - usgn(x_clear_reg));
    90            1                       1059     	diff_y       <= slv(usgn(dbb_bus.y) - usgn(y_clear_reg));
    91                                             
    92                                             	--Pix_word_cache entity
    93                                             	PWC : ENTITY work.pix_word_cache PORT MAP(
    94                                             			clk     => clk,
    95                                             			reset   => reset,
    96                                             			wen_all => wen_all,
    97                                             			pw      => pw,
    98                                             			pixopin => pixopin,
    99                                             			pixnum  => slv(pixnum),
    100                                            			is_same => is_same,
    101                                            			store   => store
    102                                            		);
    103                                            
    104                                            	--pix_write_cache entity
    105                                            	PWC2 : ENTITY work.pix_write_cache PORT MAP(
    106                                            			clk    => clk,
    107                                            			reset  => reset,
    108                                            			start  => rmw_start,
    109                                            			delay  => rmw_delay,
    110                                            			vwrite => rmw_vwrite,
    111                                            			store  => pixop_reg,
    112                                            			addr   => word_reg_out,
    113                                            			vaddr  => vaddr,
    114                                            			vdin   => vdin,
    115                                            			vdout  => vdout
    116                                            		);
    117                                            
    118                                            	--XYMUX,sel needed to be controlled by RCB-FSM
    119           1                      22763     	xymux : PROCESS(dbb_bus, x_clear_reg, y_clear_reg)
    120                                            	BEGIN
    121                                            		IF (dbb_bus.rcb_cmd = rcb_draw_white) OR (dbb_bus.rcb_cmd = rcb_draw_black) OR (dbb_bus.rcb_cmd = rcb_draw_invert) or (dbb_bus.rcb_cmd = rcb_move) THEN
    122           1                       1028     			x_in <= dbb_bus.x;
    123           1                       1028     			y_in <= dbb_bus.y;
    124                                            		ELSE
    125           1                      21735     			x_in <= x_clear_reg;
    126           1                      21735     			y_in <= y_clear_reg;
    127                                            		END IF;
    128                                            	END PROCESS xymux;
    129                                            
    130                                            	--equal block
    131           1                      11435     	EQUAL : PROCESS(split_word_addr, word_reg_out)
    132                                            	BEGIN
    133                                            		IF usgn(split_word_addr) = usgn(word_reg_out) THEN
    134           1                       5683     			equal_block_out <= '1';
    135                                            		ELSE
    136           1                       5752     			equal_block_out <= '0';
    137                                            		END IF;
    138                                            	END PROCESS EQUAL;
    139                                            
    140           1                      22277     	SPLIT : PROCESS(x_in, y_in)
    141                                            	BEGIN
    142           1                      22277     		pixnum          <= y_in(1 DOWNTO 0) & x_in(1 DOWNTO 0);
    143           1                      22277     		split_word_addr <= y_in(5 DOWNTO 2) & x_in(5 DOWNTO 2);
    144                                            
    145                                            	END PROCESS SPLIT;
    146                                            
    147                                            	--pixop decoder
    148           1                       1254     	dbb2pixop : process(dbb_bus)
    149                                            	begin
    150                                            		case dbb_bus.rcb_cmd is
    151           1                        167     			when rcb_unused       => pixopin <= psame;
    152           1                          5     			when rcb_draw_white   => pixopin <= pwhite;
    153           1                        764     			when rcb_draw_black   => pixopin <= pblack;
    154           1                        108     			when rcb_draw_invert  => pixopin <= pinvert;
    155           1                        138     			when rcb_move         => pixopin <= psame;
    156           1                         25     			when rcb_clear_white  => pixopin <= pwhite;
    157           1                         45     			when rcb_clear_black  => pixopin <= pblack;
    158           1                    ***0***     			when rcb_clear_invert => pixopin <= pinvert;
    159           1                          2     			when others           => NULL;
    160                                            		end case;
    161                                            
    162                                            	end process dbb2pixop;
    163                                            	--RCB-FSM Registered process
    164                                            	R1 : PROCESS
    165           1                          1     	BEGIN
    166           1                    2958386     		WAIT UNTIL rising_edge(clk);
    167                                            		IF reset = '1' THEN
    168                                            			--reset all register 
    169           1                         10     			rcb_state           <= idle;
    170           1                         10     			word_reg_out        <= (OTHERS => '0');
    171           1                         10     			x_clear_reg         <= (OTHERS => '0');
    172           1                         10     			y_clear_reg         <= (OTHERS => '0');
    173           1                         10     			x_clear_start       <= (OTHERS => '0');
    174           1                         10     			y_clear_start       <= (OTHERS => '0');
    175           1                         10     			pixop_reg           <= (OTHERS => psame);
    176           1                         10     			rcb_flush_downcount <= slv(to_unsigned(rcb_flush_latency, rcb_flush_downcount'LENGTH));
    177                                            		ELSE
    178                                            			IF dbb_bus.startcmd = '0' THEN
    179                                            				if usgn(rcb_flush_downcount) /= 0 then
    180           1                    2813848     					rcb_flush_downcount <= slv(usgn(rcb_flush_downcount) - 1);
    181                                            				else
    182           1                      93780     					rcb_flush_downcount <= slv(to_unsigned(rcb_flush_latency, rcb_flush_downcount'LENGTH));
    183                                            				end if;
    184                                            			ELSE
    185           1                      50747     				rcb_flush_downcount <= slv(to_unsigned(rcb_flush_latency, rcb_flush_downcount'LENGTH));
    186                                            			END IF;
    187           1                    2958375     			rcb_state <= nstate;
    188                                            			if word_reg_en = '1' then
    189           1                       5606     				word_reg_out <= slv(usgn(split_word_addr));
    190                                            			end if;
    191                                            			if pixop_reg_en = '1' then
    192           1                      99386     				pixop_reg <= store;
    193                                            			end if;
    194                                            			if clear_reg_en = '1' then
    195           1                         28     				x_clear_reg   <= x_in;
    196           1                         28     				y_clear_reg   <= y_in;
    197           1                         28     				x_clear_start <= x_in;
    198           1                         28     				y_clear_start <= y_in;
    199                                            			end if;
    200                                            			if clear_run = '1' then
    201                                            				if usgn(diff_x) = 0 then
    202                                            					if usgn(diff_y) = 0 then
    203                                            						--dx=0 and  dy=0 
    204           1                    ***0***     						NULL;
    205                                            					else
    206                                            						--dx=0 and dy!=0
    207           1                        435     						y_clear_reg <= slv(usgn(y_clear_reg) + 1);
    208           1                        435     						x_clear_reg <= x_clear_start;
    209                                            					end if;
    210                                            				else
    211           1                      21060     					x_clear_reg <= slv(usgn(x_clear_reg) + 1);
    212                                            				end if;
    213                                            			end if;
    214                                            		END IF;
    215                                            
    216                                            	END PROCESS R1;
    217                                            
    218                                            	--RCB-FSM combinational process
    219           1                    3353799     	C1 : PROCESS(rcb_state, rcb_flush_downcount, rcb_ready, dbb_bus, reset, is_same, rmw_vwrite, equal_block_out,diff_x,diff_y)
    220                                            	BEGIN
    221                                            		--defaults
    222           1                    3353799     		pw           <= '0';
    223           1                    3353799     		wen_all      <= '0';
    224           1                    3353799     		rmw_start    <= '0';
    225           1                    3353799     		rmw_delay    <= '0';
    226           1                    3353799     		rcb_ready    <= '0';
    227           1                    3353799     		rcb_skip_pw  <= '0';
    228           1                    3353799     		vwrite       <= '0';
    229           1                    3353799     		rcb_finish_1 <= '0';
    230           1                    3353799     		pixop_reg_en <= '0';
    231           1                    3353799     		word_reg_en  <= '0';
    232           1                    3353799     		clear_reg_en <= '0';
    233           1                    3353799     		clear_run<='0';
    234                                            		CASE (rcb_state) IS
    235                                            			WHEN idle =>
    236           1                    2722448     				rcb_ready <= '1';
    237                                            				IF dbb_bus.startcmd = '0' THEN
    238                                            					--clear cache if wait > N cycles
    239                                            					IF usgn(rcb_flush_downcount) = 0 THEN
    240                                            						--reset count
    241                                            						--rcb_flush_downcount <= slv(to_unsigned(rcb_flush_latency, rcb_flush_downcount'LENGTH));
    242                                            						--just write pixel word cache to RAM, DONT write pixel
    243                                            						--rmw_start           <= '1';
    244                                            						--rmw_delay           <= '0';
    245                                            						--wen_all             <= '1';
    246                                            						--skip writing of pixel to word cache
    247                                            						--rcb_skip_pw         <= '1';
    248                                            						--go to flush_done to check for vwrite, then back to idle
    249           1                      93780     						nstate <= flush_init;
    250                                            					else
    251           1                    2627223     						nstate <= idle;
    252                                            
    253                                            					END IF;
    254                                            
    255                                            				ELSE
    256                                            					--if startcommand, check same/new word
    257                                            					IF (dbb_bus.rcb_cmd = rcb_draw_white OR dbb_bus.rcb_cmd = rcb_draw_black OR dbb_bus.rcb_cmd = rcb_draw_invert) THEN
    258           1                       1303     						nstate <= draw;
    259                                            
    260                                            					elsif dbb_bus.rcb_cmd = rcb_move then
    261           1                         70     						nstate <= move;
    262                                            					else
    263           1                         72     						nstate <= clear;
    264                                            					END IF;
    265                                            				END IF;
    266                                            			WHEN flush_init =>
    267                                            				--rmw write to RAM
    268           1                     193179     				rmw_start    <= '1';
    269           1                     193179     				rmw_delay    <= '0';
    270                                            				--pix cache write all
    271           1                     193179     				wen_all      <= '1';
    272           1                     193179     				pixop_reg_en <= '1';
    273           1                     193179     				nstate       <= flush_done;
    274                                            			WHEN flush_done =>
    275           1                     391938     				vwrite <= rmw_vwrite;
    276                                            				IF rmw_vwrite = '1' THEN
    277                                            					--write pixel to word cache
    278                                            					--IF rcb_skip_pw = '0' THEN
    279                                            					--	pw <= '1';
    280                                            					--END IF;
    281                                            					if dbb_bus.startcmd = '0' then
    282           1                      93780     						nstate <= idle;
    283                                            					else
    284           1                       5606     						word_reg_en <= '1';
    285                                            						case dbb_bus.rcb_cmd is
    286           1                        168     							when rcb_draw_white | rcb_draw_black | rcb_draw_invert    => nstate <= draw;
    287           1                       5424     							when rcb_clear_white | rcb_clear_black | rcb_clear_invert => nstate <= clear;
    288           1                         14     							when rcb_move                                             => nstate <= move;
    289           1                    ***0***     							when others                                               => nstate <= idle;
    290                                            						end case;
    291                                            
    292                                            					END IF;
    293                                            				else
    294           1                     292552     					nstate <= flush_done;
    295                                            				end if;
    296                                            
    297                                            			WHEN move =>
    298           1                         98     				clear_reg_en <= '1';
    299                                            				if dbb_bus.startcmd = '1' then
    300                                            					if equal_block_out = '1' then
    301           1                         28     						nstate <= idle;
    302                                            					else
    303           1                         56     						nstate <= flush_init;
    304                                            					end if;
    305                                            				else
    306           1                         14     					nstate <= move;
    307                                            				end if;
    308                                            
    309                                            			WHEN draw =>
    310           1                       2889     				pw <= equal_block_out;
    311                                            				IF dbb_bus.startcmd = '1' THEN
    312                                            					if equal_block_out = '1' then
    313           1                       2507     						nstate <= idle;
    314                                            					else
    315           1                        364     						nstate <= flush_init;
    316                                            					end if;
    317                                            
    318                                            				else
    319           1                         18     					nstate <= idle;
    320                                            				end if;
    321                                            			--write pixel to word cache
    322                                            
    323                                            			WHEN clear =>
    324           1                      43247     				pw <= equal_block_out;
    325                                            				if equal_block_out = '1' then
    326                                            					if usgn(diff_x) = 0 and usgn(diff_y) = 0 then
    327           1                         14     						clear_run <= '0';
    328           1                         14     						nstate    <= idle;
    329                                            					else
    330           1                      32385     						clear_run <= '1';
    331           1                      32385     						nstate    <= clear;
    332                                            					end if;
    333                                            				else
    334           1                      10848     					clear_run <= '0';
    335           1                      10848     					nstate    <= flush_init;
    336                                            				end if;
    337                                            
    338           1                    ***0***     			WHEN OTHERS => NULL;
    339                                            		END CASE;
    340                                            
    341                                            		IF (usgn(rcb_flush_downcount) = 0) THEN
    342           1                      93780     			rcb_finish_1 <= rcb_ready AND (NOT dbb_bus.startcmd) AND (NOT reset) AND is_same;
    343                                            		END IF;
    344                                            
    345                                            	END PROCESS C1;
    346                                            
    347                                            END ARCHITECTURE rtl1;      
    348                                            	
    349                                            	
    350                                            	
    351                                            	
    352                                            	
    353                                            	
    354                                            	

Branch Coverage:
    Enabled Coverage        Active      Hits    Misses % Covered
    ----------------        ------      ----    ------ ---------
    Branches                    71        65         6      91.5

================================Branch Details================================

Branch Coverage for file rcb.vhd --

------------------------------------IF Branch------------------------------------
    121                                  22763     Count coming in to IF
    121           1                       1028     		IF (dbb_bus.rcb_cmd = rcb_draw_white) OR (dbb_bus.rcb_cmd = rcb_draw_black) OR (dbb_bus.rcb_cmd = rcb_draw_invert) or (dbb_bus.rcb_cmd = rcb_move) THEN
    124           1                      21735     		ELSE
Branch totals: 2 hits of 2 branches = 100.0%

------------------------------------IF Branch------------------------------------
    133                                  11435     Count coming in to IF
    133           1                       5683     		IF usgn(split_word_addr) = usgn(word_reg_out) THEN
    135           1                       5752     		ELSE
Branch totals: 2 hits of 2 branches = 100.0%

------------------------------------CASE Branch------------------------------------
    150                                   1254     Count coming in to CASE
    151           1                        167     			when rcb_unused       => pixopin <= psame;
    152           1                          5     			when rcb_draw_white   => pixopin <= pwhite;
    153           1                        764     			when rcb_draw_black   => pixopin <= pblack;
    154           1                        108     			when rcb_draw_invert  => pixopin <= pinvert;
    155           1                        138     			when rcb_move         => pixopin <= psame;
    156           1                         25     			when rcb_clear_white  => pixopin <= pwhite;
    157           1                         45     			when rcb_clear_black  => pixopin <= pblack;
    158           1                    ***0***     			when rcb_clear_invert => pixopin <= pinvert;
    159           1                          2     			when others           => NULL;
Branch totals: 8 hits of 9 branches = 88.8%

------------------------------------IF Branch------------------------------------
    167                                2958385     Count coming in to IF
    167           1                         10     		IF reset = '1' THEN
    177           1                    2958375     		ELSE
Branch totals: 2 hits of 2 branches = 100.0%

------------------------------------IF Branch------------------------------------
    178                                2958375     Count coming in to IF
    178           1                    2907628     			IF dbb_bus.startcmd = '0' THEN
    184           1                      50747     			ELSE
Branch totals: 2 hits of 2 branches = 100.0%

------------------------------------IF Branch------------------------------------
    179                                2907628     Count coming in to IF
    179           1                    2813848     				if usgn(rcb_flush_downcount) /= 0 then
    181           1                      93780     				else
Branch totals: 2 hits of 2 branches = 100.0%

------------------------------------IF Branch------------------------------------
    188                                2958375     Count coming in to IF
    188           1                       5606     			if word_reg_en = '1' then
                                       2952769     All False Count
Branch totals: 2 hits of 2 branches = 100.0%

------------------------------------IF Branch------------------------------------
    191                                2958375     Count coming in to IF
    191           1                      99386     			if pixop_reg_en = '1' then
                                       2858989     All False Count
Branch totals: 2 hits of 2 branches = 100.0%

------------------------------------IF Branch------------------------------------
    194                                2958375     Count coming in to IF
    194           1                         28     			if clear_reg_en = '1' then
                                       2958347     All False Count
Branch totals: 2 hits of 2 branches = 100.0%

------------------------------------IF Branch------------------------------------
    200                                2958375     Count coming in to IF
    200           1                      21495     			if clear_run = '1' then
                                       2936880     All False Count
Branch totals: 2 hits of 2 branches = 100.0%

------------------------------------IF Branch------------------------------------
    201                                  21495     Count coming in to IF
    201           1                        435     				if usgn(diff_x) = 0 then
    210           1                      21060     				else
Branch totals: 2 hits of 2 branches = 100.0%

------------------------------------IF Branch------------------------------------
    202                                    435     Count coming in to IF
    202           1                    ***0***     					if usgn(diff_y) = 0 then
    205           1                        435     					else
Branch totals: 1 hit of 2 branches = 50.0%

------------------------------------CASE Branch------------------------------------
    234                                3353799     Count coming in to CASE
    235           1                    2722448     			WHEN idle =>
    266           1                     193179     			WHEN flush_init =>
    274           1                     391938     			WHEN flush_done =>
    297           1                         98     			WHEN move =>
    309           1                       2889     			WHEN draw =>
    323           1                      43247     			WHEN clear =>
    338           1                    ***0***     			WHEN OTHERS => NULL;
Branch totals: 6 hits of 7 branches = 85.7%

------------------------------------IF Branch------------------------------------
    237                                2722448     Count coming in to IF
    237           1                    2721003     				IF dbb_bus.startcmd = '0' THEN
    255           1                       1445     				ELSE
Branch totals: 2 hits of 2 branches = 100.0%

------------------------------------IF Branch------------------------------------
    239                                2721003     Count coming in to IF
    239           1                      93780     					IF usgn(rcb_flush_downcount) = 0 THEN
    250           1                    2627223     					else
Branch totals: 2 hits of 2 branches = 100.0%

------------------------------------IF Branch------------------------------------
    257                                   1445     Count coming in to IF
    257           1                       1303     					IF (dbb_bus.rcb_cmd = rcb_draw_white OR dbb_bus.rcb_cmd = rcb_draw_black OR dbb_bus.rcb_cmd = rcb_draw_invert) THEN
    260           1                         70     					elsif dbb_bus.rcb_cmd = rcb_move then
    262           1                         72     					else
Branch totals: 3 hits of 3 branches = 100.0%

------------------------------------IF Branch------------------------------------
    276                                 391938     Count coming in to IF
    276           1                      99386     				IF rmw_vwrite = '1' THEN
    293           1                     292552     				else
Branch totals: 2 hits of 2 branches = 100.0%

------------------------------------IF Branch------------------------------------
    281                                  99386     Count coming in to IF
    281           1                      93780     					if dbb_bus.startcmd = '0' then
    283           1                       5606     					else
Branch totals: 2 hits of 2 branches = 100.0%

------------------------------------CASE Branch------------------------------------
    285                                   5606     Count coming in to CASE
    286           1                    ***0***     							when rcb_draw_white | rcb_draw_black | rcb_draw_invert    => nstate <= draw;
    286           2                        158     
    286           3                         10     
    287           1                       5115     							when rcb_clear_white | rcb_clear_black | rcb_clear_invert => nstate <= clear;
    287           2                        309     
    287           3                    ***0***     
    288           1                         14     							when rcb_move                                             => nstate <= move;
    289           1                    ***0***     							when others                                               => nstate <= idle;
Branch totals: 5 hits of 8 branches = 62.5%

------------------------------------IF Branch------------------------------------
    299                                     98     Count coming in to IF
    299           1                         84     				if dbb_bus.startcmd = '1' then
    305           1                         14     				else
Branch totals: 2 hits of 2 branches = 100.0%

------------------------------------IF Branch------------------------------------
    300                                     84     Count coming in to IF
    300           1                         28     					if equal_block_out = '1' then
    302           1                         56     					else
Branch totals: 2 hits of 2 branches = 100.0%

------------------------------------IF Branch------------------------------------
    311                                   2889     Count coming in to IF
    311           1                       2871     				IF dbb_bus.startcmd = '1' THEN
    318           1                         18     				else
Branch totals: 2 hits of 2 branches = 100.0%

------------------------------------IF Branch------------------------------------
    312                                   2871     Count coming in to IF
    312           1                       2507     					if equal_block_out = '1' then
    314           1                        364     					else
Branch totals: 2 hits of 2 branches = 100.0%

------------------------------------IF Branch------------------------------------
    325                                  43247     Count coming in to IF
    325           1                      32399     				if equal_block_out = '1' then
    333           1                      10848     				else
Branch totals: 2 hits of 2 branches = 100.0%

------------------------------------IF Branch------------------------------------
    326                                  32399     Count coming in to IF
    326           1                         14     					if usgn(diff_x) = 0 and usgn(diff_y) = 0 then
    329           1                      32385     					else
Branch totals: 2 hits of 2 branches = 100.0%

------------------------------------IF Branch------------------------------------
    341                                3353799     Count coming in to IF
    341           1                      93780     		IF (usgn(rcb_flush_downcount) = 0) THEN
                                       3260019     All False Count
Branch totals: 2 hits of 2 branches = 100.0%


Condition Coverage:
    Enabled Coverage        Active   Covered    Misses % Covered
    ----------------        ------      ----    ------ ---------
    FEC Condition Terms          9         9         0     100.0

================================Condition Details================================

Condition Coverage for file rcb.vhd --

----------------Focused Condition View-------------------
Line       121 Item    1 		IF (dbb_bus.rcb_cmd = rcb_draw_white) OR (dbb_bus.rcb_cmd = rcb_draw_black) OR (dbb_bus.rcb_cmd = rcb_draw_invert) or (dbb_bus.rcb_cmd = rcb_move) THEN
Condition totals: 4 of 4 input terms covered = 100.0%

                           Input Term   Covered  Reason for no coverage   Hint
                          -----------  --------  -----------------------  --------------
   (dbb_bus.rcb_cmd = rcb_draw_white)         Y
   (dbb_bus.rcb_cmd = rcb_draw_black)         Y
  (dbb_bus.rcb_cmd = rcb_draw_invert)         Y
         (dbb_bus.rcb_cmd = rcb_move)         Y

     Rows:       Hits  FEC Target                             Matching input patterns       
 ---------  ---------  --------------------                   -------------------------     
  Row   1:      21735  (dbb_bus.rcb_cmd = rcb_draw_white)_0   { 0000 }                      
  Row   2:          5  (dbb_bus.rcb_cmd = rcb_draw_white)_1   { 1--- }                      
  Row   3:      21735  (dbb_bus.rcb_cmd = rcb_draw_black)_0   { 0000 }                      
  Row   4:        764  (dbb_bus.rcb_cmd = rcb_draw_black)_1   { 01-- }                      
  Row   5:      21735  (dbb_bus.rcb_cmd = rcb_draw_invert)_0  { 0000 }                      
  Row   6:        108  (dbb_bus.rcb_cmd = rcb_draw_invert)_1  { 001- }                      
  Row   7:      21735  (dbb_bus.rcb_cmd = rcb_move)_0         { 0000 }                      
  Row   8:        151  (dbb_bus.rcb_cmd = rcb_move)_1         { 0001 }                      

NOTE:
  * Order of matching input pattern values: {(dbb_bus.rcb_cmd = rcb_draw_white),(dbb_bus.rcb_cmd = rcb_draw_black),(dbb_bus.rcb_cmd = rcb_draw_invert),(dbb_bus.rcb_cmd = rcb_move)}

----------------Focused Condition View-------------------
Line       257 Item    1 					IF (dbb_bus.rcb_cmd = rcb_draw_white OR dbb_bus.rcb_cmd = rcb_draw_black OR dbb_bus.rcb_cmd = rcb_draw_invert) THEN
Condition totals: 3 of 3 input terms covered = 100.0%

                           Input Term   Covered  Reason for no coverage   Hint
                          -----------  --------  -----------------------  --------------
   (dbb_bus.rcb_cmd = rcb_draw_white)         Y
   (dbb_bus.rcb_cmd = rcb_draw_black)         Y
  (dbb_bus.rcb_cmd = rcb_draw_invert)         Y

     Rows:       Hits  FEC Target                             Matching input patterns       
 ---------  ---------  --------------------                   -------------------------     
  Row   1:        142  (dbb_bus.rcb_cmd = rcb_draw_white)_0   { 000 }                       
  Row   2:          3  (dbb_bus.rcb_cmd = rcb_draw_white)_1   { 1-- }                       
  Row   3:        142  (dbb_bus.rcb_cmd = rcb_draw_black)_0   { 000 }                       
  Row   4:       1204  (dbb_bus.rcb_cmd = rcb_draw_black)_1   { 01- }                       
  Row   5:        142  (dbb_bus.rcb_cmd = rcb_draw_invert)_0  { 000 }                       
  Row   6:         96  (dbb_bus.rcb_cmd = rcb_draw_invert)_1  { 001 }                       

NOTE:
  * Order of matching input pattern values: {(dbb_bus.rcb_cmd = rcb_draw_white),(dbb_bus.rcb_cmd = rcb_draw_black),(dbb_bus.rcb_cmd = rcb_draw_invert)}

----------------Focused Condition View-------------------
Line       326 Item    1 					if usgn(diff_x) = 0 and usgn(diff_y) = 0 then
Condition totals: 2 of 2 input terms covered = 100.0%

            Input Term   Covered  Reason for no coverage   Hint
           -----------  --------  -----------------------  --------------
  ((<type>)diff_x = 0)         Y
  ((<type>)diff_y = 0)         Y

     Rows:       Hits  FEC Target              Matching input patterns       
 ---------  ---------  --------------------    -------------------------     
  Row   1:      31937  ((<type>)diff_x = 0)_0  { 0- }                        
  Row   2:         14  ((<type>)diff_x = 0)_1  { 11 }                        
  Row   3:        448  ((<type>)diff_y = 0)_0  { 10 }                        
  Row   4:         14  ((<type>)diff_y = 0)_1  { 11 }                        

NOTE:
  * Order of matching input pattern values: {((<type>)diff_x = 0),((<type>)diff_y = 0)}


Expression Coverage:
    Enabled Coverage        Active   Covered    Misses % Covered
    ----------------        ------      ----    ------ ---------
    FEC Expression Terms         4         1         3      25.0

================================Expression Details================================

Expression Coverage for file rcb.vhd --

----------------Focused Expression View-----------------
Line       342 Item    1 			rcb_finish_1 <= rcb_ready AND (NOT dbb_bus.startcmd) AND (NOT reset) AND is_same;
Expression totals: 1 of 4 input terms covered = 25.0%

        Input Term   Covered  Reason for no coverage   Hint
       -----------  --------  -----------------------  --------------
         rcb_ready         N  '_0' not hit             Hit '_0'
  dbb_bus.startcmd         N  '_1' not hit             Hit '_1'
             reset         N  '_1' not hit             Hit '_1'
           is_same         Y

     Rows:       Hits  FEC Target            Matching input patterns       
 ---------  ---------  --------------------  -------------------------     
  Row   1:    ***0***  rcb_ready_0           { 0001 }                      
  Row   2:      93779  rcb_ready_1           { 1001 }                      
  Row   3:      93779  dbb_bus.startcmd_0    { 1001 }                      
  Row   4:    ***0***  dbb_bus.startcmd_1    { 1101 }                      
  Row   5:      93779  reset_0               { 1001 }                      
  Row   6:    ***0***  reset_1               { 1011 }                      
  Row   7:          1  is_same_0             { 1000 }                      
  Row   8:      93779  is_same_1             { 1001 }                      

NOTE:
  * Order of matching input pattern values: {rcb_ready,dbb_bus.startcmd,reset,is_same}


FSM Coverage:
    Enabled Coverage        Active      Hits    Misses % Covered
    ----------------        ------      ----    ------ ---------
    States                       6         6         0     100.0
    Transitions                 20        18         2      90.0

================================FSM Details================================

FSM Coverage for file rcb.vhd --

FSM_ID: rcb_state
    Current State Object : rcb_state
    ----------------------
    State Value MapInfo :
    ---------------------
Line          State Name               Value
----          ----------               -----
 235                idle                   0
 323               clear                   5
 297                move                   1
 309                draw                   4
 266          flush_init                   2
 274          flush_done                   3
    Covered States :
    ----------------
                   State           Hit_count
                   -----           ---------
                    idle             2533129
                   clear               26933
                    move                  28
                    draw                 751
              flush_init               99386
              flush_done              298158
    Covered Transitions :
    ---------------------
Line            Trans_ID           Hit_count          Transition          
----            --------           ---------          ----------          
 249                   0               93780          idle -> flush_init  
 251                   1             2438738          idle -> idle        
 258                   2                 583          idle -> draw        
 261                   3                  14          idle -> move        
 263                   4                  14          idle -> clear       
 328                   5                  14          clear -> idle       
 331                   6               21495          clear -> clear      
 335                   7                5424          clear -> flush_init 
 301                   8                  14          move -> idle        
 303                   9                  14          move -> flush_init  
 313                  11                 583          draw -> idle        
 315                  12                 168          draw -> flush_init  
 273                  13               99386          flush_init -> flush_done
 282                  15               93780          flush_done -> idle  
 286                  16                 168          flush_done -> draw  
 287                  17                5424          flush_done -> clear 
 288                  18                  14          flush_done -> move  
 294                  19              198772          flush_done -> flush_done
    Uncovered Transitions :
    -----------------------
Line            Trans_ID          Transition          
----            --------          ----------          
 306                  10          move -> move        
 169                  14          flush_init -> idle  


    Summary                 Active      Hits    Misses % Covered
    -------                 ------      ----    ------ ---------
    States                       6         6         0     100.0
    Transitions                 20        18         2      90.0
Toggle Coverage:
    Enabled Coverage        Active      Hits    Misses % Covered
    ----------------        ------      ----    ------ ---------
    Toggle Bins                318       299        19      94.0

================================Toggle Details================================

Toggle Coverage for File rcb.vhd --

       Line                                   Node      1H->0L      0L->1H                          "Coverage"
--------------------------------------------------------------------------------------------------------------
         13                                    clk           1           1                              100.00 
         14                                  reset           1           0                               50.00 
         17                       dbb_bus.startcmd           1           1                              100.00 
         17                     dbb_bus.rcb_cmd(2)           1           1                              100.00 
         17                     dbb_bus.rcb_cmd(1)           1           1                              100.00 
         17                     dbb_bus.rcb_cmd(0)           1           1                              100.00 
         17                           dbb_bus.Y(5)           1           1                              100.00 
         17                           dbb_bus.Y(4)           1           1                              100.00 
         17                           dbb_bus.Y(3)           1           1                              100.00 
         17                           dbb_bus.Y(2)           1           1                              100.00 
         17                           dbb_bus.Y(1)           1           1                              100.00 
         17                           dbb_bus.Y(0)           1           1                              100.00 
         17                           dbb_bus.X(5)           1           1                              100.00 
         17                           dbb_bus.X(4)           1           1                              100.00 
         17                           dbb_bus.X(3)           1           1                              100.00 
         17                           dbb_bus.X(2)           1           1                              100.00 
         17                           dbb_bus.X(1)           1           1                              100.00 
         17                           dbb_bus.X(0)           1           1                              100.00 
         18                           dbb_delaycmd           1           1                              100.00 
         21                               vdout(9)           1           1                              100.00 
         21                               vdout(8)           1           1                              100.00 
         21                               vdout(7)           1           1                              100.00 
         21                               vdout(6)           1           1                              100.00 
         21                               vdout(5)           1           1                              100.00 
         21                               vdout(4)           1           1                              100.00 
         21                               vdout(3)           1           1                              100.00 
         21                               vdout(2)           1           1                              100.00 
         21                              vdout(15)           1           1                              100.00 
         21                              vdout(14)           1           1                              100.00 
         21                              vdout(13)           1           1                              100.00 
         21                              vdout(12)           1           1                              100.00 
         21                              vdout(11)           1           1                              100.00 
         21                              vdout(10)           1           1                              100.00 
         21                               vdout(1)           1           1                              100.00 
         21                               vdout(0)           1           1                              100.00 
         22                                vdin(9)           1           1                              100.00 
         22                                vdin(8)           1           1                              100.00 
         22                                vdin(7)           1           1                              100.00 
         22                                vdin(6)           1           1                              100.00 
         22                                vdin(5)           1           1                              100.00 
         22                                vdin(4)           1           1                              100.00 
         22                                vdin(3)           1           1                              100.00 
         22                                vdin(2)           1           1                              100.00 
         22                               vdin(15)           1           1                              100.00 
         22                               vdin(14)           1           1                              100.00 
         22                               vdin(13)           1           1                              100.00 
         22                               vdin(12)           1           1                              100.00 
         22                               vdin(11)           1           1                              100.00 
         22                               vdin(10)           1           1                              100.00 
         22                                vdin(1)           1           1                              100.00 
         22                                vdin(0)           1           1                              100.00 
         23                                 vwrite           1           1                              100.00 
         24                               vaddr(7)           1           1                              100.00 
         24                               vaddr(6)           1           1                              100.00 
         24                               vaddr(5)           1           1                              100.00 
         24                               vaddr(4)           1           1                              100.00 
         24                               vaddr(3)           1           1                              100.00 
         24                               vaddr(2)           1           1                              100.00 
         24                               vaddr(1)           1           1                              100.00 
         24                               vaddr(0)           1           1                              100.00 
         27                             rcb_finish           1           1                              100.00 
         35                           rcb_finish_1           1           1                              100.00 
         38                                x_in(5)           1           1                              100.00 
         38                                x_in(4)           1           1                              100.00 
         38                                x_in(3)           1           1                              100.00 
         38                                x_in(2)           1           1                              100.00 
         38                                x_in(1)           1           1                              100.00 
         38                                x_in(0)           1           1                              100.00 
         39                                y_in(5)           1           1                              100.00 
         39                                y_in(4)           1           1                              100.00 
         39                                y_in(3)           1           1                              100.00 
         39                                y_in(2)           1           1                              100.00 
         39                                y_in(1)           1           1                              100.00 
         39                                y_in(0)           1           1                              100.00 
         40                        equal_block_out           1           1                              100.00 
         41                     split_word_addr(7)           1           1                              100.00 
         41                     split_word_addr(6)           1           1                              100.00 
         41                     split_word_addr(5)           1           1                              100.00 
         41                     split_word_addr(4)           1           1                              100.00 
         41                     split_word_addr(3)           1           1                              100.00 
         41                     split_word_addr(2)           1           1                              100.00 
         41                     split_word_addr(1)           1           1                              100.00 
         41                     split_word_addr(0)           1           1                              100.00 
         44                        word_reg_out(7)           1           1                              100.00 
         44                        word_reg_out(6)           1           1                              100.00 
         44                        word_reg_out(5)           1           1                              100.00 
         44                        word_reg_out(4)           1           1                              100.00 
         44                        word_reg_out(3)           1           1                              100.00 
         44                        word_reg_out(2)           1           1                              100.00 
         44                        word_reg_out(1)           1           1                              100.00 
         44                        word_reg_out(0)           1           1                              100.00 
         45                         x_clear_reg(5)           1           1                              100.00 
         45                         x_clear_reg(4)           1           1                              100.00 
         45                         x_clear_reg(3)           1           1                              100.00 
         45                         x_clear_reg(2)           1           1                              100.00 
         45                         x_clear_reg(1)           1           1                              100.00 
         45                         x_clear_reg(0)           1           1                              100.00 
         46                         y_clear_reg(5)           1           1                              100.00 
         46                         y_clear_reg(4)           1           1                              100.00 
         46                         y_clear_reg(3)           1           1                              100.00 
         46                         y_clear_reg(2)           1           1                              100.00 
         46                         y_clear_reg(1)           1           1                              100.00 
         46                         y_clear_reg(0)           1           1                              100.00 
         47                       x_clear_start(5)           0           0                                0.00 
         47                       x_clear_start(4)           1           1                              100.00 
         47                       x_clear_start(3)           1           1                              100.00 
         47                       x_clear_start(2)           1           1                              100.00 
         47                       x_clear_start(1)           0           0                                0.00 
         47                       x_clear_start(0)           1           1                              100.00 
         48                       y_clear_start(5)           0           0                                0.00 
         48                       y_clear_start(4)           1           1                              100.00 
         48                       y_clear_start(3)           1           1                              100.00 
         48                       y_clear_start(2)           1           1                              100.00 
         48                       y_clear_start(1)           0           0                                0.00 
         48                       y_clear_start(0)           1           1                              100.00 
         52                           clear_reg_en           1           1                              100.00 
         53                            word_reg_en           1           1                              100.00 
         54                           pixop_reg_en           1           1                              100.00 
         57                              diff_x(5)           1           1                              100.00 
         57                              diff_x(4)           1           1                              100.00 
         57                              diff_x(3)           1           1                              100.00 
         57                              diff_x(2)           1           1                              100.00 
         57                              diff_x(1)           1           1                              100.00 
         57                              diff_x(0)           1           1                              100.00 
         58                              diff_y(5)           1           1                              100.00 
         58                              diff_y(4)           1           1                              100.00 
         58                              diff_y(3)           1           1                              100.00 
         58                              diff_y(2)           1           1                              100.00 
         58                              diff_y(1)           1           1                              100.00 
         58                              diff_y(0)           1           1                              100.00 
         59                              clear_run           1           1                              100.00 
         63                              rcb_state               ENUM type       Value       Count 
                                                                      idle         298      100.00 
                                                                      move           2      100.00 
                                                                flush_init          96      100.00 
                                                                flush_done          96      100.00 
                                                                      draw         392      100.00 
                                                                     clear           1      100.00 
         63                                 nstate               ENUM type       Value       Count 
                                                                      idle         281      100.00 
                                                                      move           1      100.00 
                                                                flush_init         111      100.00 
                                                                flush_done          95      100.00 
                                                                      draw         409      100.00 
                                                                     clear           1      100.00 
         64                 rcb_flush_downcount(7)           0           0                                0.00 
         64                 rcb_flush_downcount(6)           0           0                                0.00 
         64                 rcb_flush_downcount(5)           0           0                                0.00 
         64                 rcb_flush_downcount(4)           1           1                              100.00 
         64                 rcb_flush_downcount(3)           1           1                              100.00 
         64                 rcb_flush_downcount(2)           1           1                              100.00 
         64                 rcb_flush_downcount(1)           1           1                              100.00 
         64                 rcb_flush_downcount(0)           1           1                              100.00 
         65                              rcb_ready           1           1                              100.00 
         66                            rcb_skip_pw           0           0                                0.00 
         69                              rmw_start           1           1                              100.00 
         70                              rmw_delay           0           0                                0.00 
         71                             rmw_vwrite           1           1                              100.00 
         74                                wen_all           1           1                              100.00 
         74                                     pw           1           1                              100.00 
         75                             pixopin(1)           1           1                              100.00 
         75                             pixopin(0)           1           1                              100.00 
         76                              pixnum(3)           1           1                              100.00 
         76                              pixnum(2)           1           1                              100.00 
         76                              pixnum(1)           1           1                              100.00 
         76                              pixnum(0)           1           1                              100.00 
         77                                is_same           1           1                              100.00 

Total Node Count     =        165 
Toggled Node Count   =        155 
Untoggled Node Count =         10 

Toggle Coverage      =       94.0% (299 of 318 bins)


ASSERTION RESULTS:
-------------------------------------------------------
Name                 File(Line)           Failure Pass 
                                          Count   Count 
-------------------------------------------------------
/vdp_testbench/MAIN#immed__165
                     vdp_testbench.vhd(165)       1     -
/vdp_testbench/RAM1/line__35
                     vram.vhd(35)               0     -
/vdp_pack/do_vdp_command#immed__568
                     vdp_pack.vhd(568)          0     -
/vdp_pack/send_vdp_command#immed__365
                     vdp_pack.vhd(365)          0     -
/vdp_pack/send_vdp_command#immed__345
                     vdp_pack.vhd(345)          0     -
/vdp_pack/display_ram#immed__303
                     vdp_pack.vhd(303)          0     -


